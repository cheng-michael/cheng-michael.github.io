<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>michael cheng</title>
    <style>
        :root {
            /* LIGHT MODE */
            --bg: #ffffff;
            --headings: #000000;
            --text: #555555;
            --btn-active: #000000;
        }

        body.dark-mode {
            /* DARK MODE */
            --bg: #111111;
            --headings: #ffffff;
            --text: #a0a0a0;
            --btn-active: #ffffff;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background-color: var(--bg);
            color: var(--text);
            font-family: Menlo, Monaco, Consolas, "Courier New", monospace;
            font-size: 14px;
            line-height: 1.6;
            text-transform: lowercase;
            
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 2rem;
            
            transition: background-color 0.3s, color 0.3s;
            overflow-x: hidden;
            /* Allow selection now */
            user-select: text; 
        }

        main {
            max-width: 520px;
            width: 100%;
            text-align: left;
            position: relative;
            /* Ensure content sits above ripples but blends in */
            z-index: 10; 
        }

        h1 {
            color: var(--headings);
            font-size: 14px;
            font-weight: normal;
            margin-bottom: 2rem;
        }

        p {
            margin-bottom: 2rem;
        }

        ul {
            list-style: none;
            margin-bottom: 2rem;
        }

        li {
            margin-bottom: 0.5rem;
        }

        a {
            color: inherit;
            text-decoration: underline;
            cursor: pointer;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--headings);
            text-decoration: underline; 
        }

        /* BUTTONS */
        .corner-btn {
            position: fixed;
            bottom: 2rem;
            background: none;
            border: none;
            color: var(--text);
            font-family: inherit;
            font-size: 14px;
            cursor: pointer;
            text-decoration: underline;
            padding: 0.5rem;
            opacity: 0.7;
            z-index: 20;
            user-select: none; /* Keep buttons unselectable */
        }

        .corner-btn:hover {
            color: var(--headings);
            opacity: 1;
        }

        .corner-btn:active {
            color: var(--headings);
        }

        #theme-toggle { right: 2rem; }
        #ripple-trigger { left: 2rem; }

        @media (max-width: 768px) {
            #ripple-trigger {
                display: none;
            }
        }

        /* DOM RIPPLE CONTAINER */
        /* This replaces the canvas */
        #ripple-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass through, but allow selection */
            z-index: 1;
            overflow: hidden;
        }

        /* The individual ripple characters */
        .ripple-char {
            position: absolute;
            pointer-events: auto; /* This makes them SELECTABLE */
            user-select: text;
            will-change: transform, opacity; /* optimization */
            white-space: pre; /* preserves width of spaces if used */
        }

    </style>
</head>
<body>

    <div id="ripple-container"></div>

    <main id="content-block">
        <h1>michael cheng</h1>

        <p>
            lorem ipsum dolor sit amet, consectetur adipiscing elit. sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
        </p>

        <ul>
            <li>
                <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#109;&#101;&#64;&#109;&#105;&#99;&#104;&#97;&#101;&#108;&#99;&#104;&#101;&#110;&#103;&#46;&#100;&#101;&#118;">email</a>
            </li>
            <li>
                <a href="https://github.com/michaelchengdev">github</a>
            </li>
            <li>
                <a href="https://www.linkedin.com/in/michaelchengdev/">linkedin</a>
            </li>
        </ul>

        <p>
            viverra ipsum nunc aliquet bibendum enim facilisis gravida neque convallis.
        </p>
    </main>

    <button id="ripple-trigger" class="corner-btn">rain</button>
    <button id="theme-toggle" class="corner-btn">dark</button>

    <script>
        const toggleButton = document.getElementById('theme-toggle');
        const body = document.body;

        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            body.classList.add('dark-mode');
            toggleButton.textContent = 'light';
        }

        toggleButton.addEventListener('click', () => {
            body.classList.toggle('dark-mode');
            toggleButton.textContent = body.classList.contains('dark-mode') ? 'light' : 'dark';
        });

        // --- DOM-BASED RIPPLE ENGINE ---
        const container = document.getElementById('ripple-container');
        const triggerBtn = document.getElementById('ripple-trigger');
        const contentBlock = document.getElementById('content-block');
        
        const DENSITY_TIERS = [
            ['@', '#', 'O', '0', '8', '&'], 
            ['o', '*', 'x', '%', 'z'],
            ['+', '=', '~', '-', '^'],
            ['.', ',', '\'', '`', '_']      
        ];
        
        // GRID SETTINGS
        const FONT_SIZE = 14; 
        const LINE_HEIGHT = 1.6;
        const CELL_HEIGHT = FONT_SIZE * LINE_HEIGHT; 
        const CELL_WIDTH = FONT_SIZE * 0.6; 
        
        let drops = [];
        let w = window.innerWidth;
        let h = window.innerHeight;
        
        // --- OBJECT POOL FOR PERFORMANCE ---
        // Creating/deleting DOM nodes is slow. We create a pool of reusable spans.
        const MAX_PARTICLES = 400; // Hard limit to prevent browser lag
        const spanPool = [];
        
        // Initialize Pool
        for (let i = 0; i < MAX_PARTICLES; i++) {
            const span = document.createElement('span');
            span.className = 'ripple-char';
            span.style.opacity = '0'; // Hidden by default
            container.appendChild(span);
            spanPool.push(span);
        }

        // CONTROL VARIABLES
        let isHolding = false;
        let spawnRate = 0;          
        let maxSpawnRate = 1.5;      
        let rampUpSpeed = 0.05;      
        let rampDownSpeed = 0.02;    

        window.addEventListener('resize', () => {
            w = window.innerWidth;
            h = window.innerHeight;
        });

        class RealisticDrop {
            constructor() {
                const rect = contentBlock.getBoundingClientRect();
                const padding = 50; 
                const side = Math.random() > 0.5 ? 'left' : 'right';
                
                if (side === 'left') {
                    this.x = Math.random() * (rect.left - padding);
                } else {
                    this.x = (rect.right + padding) + Math.random() * (w - (rect.right + padding));
                }
                this.y = Math.random() * h;
                
                const r = Math.random();
                if (r < 0.60) {
                    this.type = 'small';
                } else if (r < 0.90) {
                    this.type = 'medium';
                } else {
                    this.type = 'large';
                }

                this.age = 0;
                this.isDead = false;
                this.friction = 0.96; 
                this.radius = 0;

                if (this.type === 'small') {
                    this.maxAge = 50 + Math.random() * 20;  
                    this.velocity = 1.5 + Math.random();    
                    this.waveLength = 8 + Math.random() * 4;
                    this.maxIntensity = 0.5;                
                } else if (this.type === 'medium') {
                    this.maxAge = 80 + Math.random() * 30;
                    this.velocity = 2.0 + Math.random();
                    this.waveLength = 14 + Math.random() * 5;
                    this.maxIntensity = 0.8;                
                } else { 
                    this.maxAge = 120 + Math.random() * 40; 
                    this.velocity = 2.8 + Math.random();    
                    this.waveLength = 22 + Math.random() * 8; 
                    this.maxIntensity = 1.0;                
                }
            }

            update() {
                this.age++;
                this.radius += this.velocity;
                if (this.velocity > 0.2) this.velocity *= this.friction;
                if (this.age > this.maxAge) this.isDead = true;
            }

            getRings() {
                const rings = [];
                let progress = this.age / this.maxAge;
                let baseIntensity = this.maxIntensity * (1 - progress);
                if (baseIntensity <= 0) return [];

                for (let i = 0; i < 3; i++) {
                    const offset = i * this.waveLength;
                    const r = this.radius - offset;
                    if (r <= 0) continue;

                    let ringIntensity = baseIntensity * (1 - (i * 0.3));
                    ringIntensity *= (60 / (r + 60)); 

                    if (ringIntensity > 0.05) {
                        rings.push({ r: r, intensity: ringIntensity });
                    }
                }
                return rings;
            }
        }

        triggerBtn.addEventListener('mousedown', () => { isHolding = true; });
        triggerBtn.addEventListener('mouseup', () => { isHolding = false; });
        triggerBtn.addEventListener('mouseleave', () => { isHolding = false; });
        triggerBtn.addEventListener('click', () => { spawnRate = Math.min(spawnRate + 1, maxSpawnRate); });

        // --- ANIMATION LOOP ---
        function animate() {
            // 1. Logic Updates
            if (isHolding) {
                if (spawnRate < maxSpawnRate) spawnRate += rampUpSpeed;
            } else {
                if (spawnRate > 0) spawnRate -= rampDownSpeed;
            }
            if (spawnRate < 0) spawnRate = 0;

            if (spawnRate > 0) {
                const chance = Math.random() * 10;
                if (chance < spawnRate) drops.push(new RealisticDrop());
            }

            drops = drops.filter(d => !d.isDead);
            
            // 2. Render Phase - DOM Recycling
            let poolIndex = 0;
            const contentRect = contentBlock.getBoundingClientRect();
            
            // NOTE: We don't "clear" the DOM. We just overwrite the spans we need
            // and hide the rest at the end.

            drops.forEach(drop => {
                drop.update();
                const rings = drop.getRings();

                rings.forEach(ring => {
                    if (poolIndex >= MAX_PARTICLES) return; // Pool exhausted

                    let safeIntensity = Math.max(0, Math.min(1, ring.intensity));
                    let tierIndex = Math.floor((1 - safeIntensity) * DENSITY_TIERS.length);
                    tierIndex = Math.max(0, Math.min(DENSITY_TIERS.length - 1, tierIndex));
                    
                    const charSet = DENSITY_TIERS[tierIndex];
                    const alpha = safeIntensity < 0.3 ? safeIntensity * 3 : 1;

                    const circumference = 2 * Math.PI * ring.r;
                    const steps = Math.floor(circumference / CELL_WIDTH);
                    
                    for (let i = 0; i < steps; i++) {
                        if (poolIndex >= MAX_PARTICLES) break;

                        const angle = (i / steps) * Math.PI * 2;
                        
                        // Raw coordinates
                        const rawX = drop.x + Math.cos(angle) * ring.r;
                        const rawY = drop.y + Math.sin(angle) * ring.r;

                        // Bounds check
                        if (rawX < 0 || rawX > w || rawY < 0 || rawY > h) continue;

                        // Collision check
                        if (rawX > contentRect.left - 20 && rawX < contentRect.right + 20 &&
                            rawY > contentRect.top - 20 && rawY < contentRect.bottom + 20) {
                            continue;
                        }

                        // GRID SNAP
                        const col = Math.floor(rawX / CELL_WIDTH);
                        const row = Math.floor(rawY / CELL_HEIGHT);
                        const snappedX = col * CELL_WIDTH;
                        const snappedY = row * CELL_HEIGHT + (CELL_HEIGHT - FONT_SIZE)/2;

                        // Get a span from the pool
                        const span = spanPool[poolIndex];
                        poolIndex++;

                        // Stable char selection
                        const hash = col + row; 
                        const selectedChar = charSet[hash % charSet.length];

                        // Update DOM Properties
                        // Use translate3d for GPU acceleration
                        span.style.transform = `translate3d(${snappedX}px, ${snappedY}px, 0)`;
                        span.textContent = selectedChar;
                        span.style.opacity = alpha;
                        
                        // Handle Theme Colors via CSS variable if possible, 
                        // but here JS is driving the color logic for simplicity
                        const isDark = body.classList.contains('dark-mode');
                        span.style.color = isDark ? `rgba(255, 255, 255, 1)` : `rgba(0, 0, 0, 1)`;
                    }
                });
            });

            // 3. Cleanup Phase
            // Hide all unused spans in the pool
            for (let i = poolIndex; i < MAX_PARTICLES; i++) {
                spanPool[i].style.opacity = '0';
            }

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>

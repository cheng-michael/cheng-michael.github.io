<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Michael Cheng</title>
    <meta name="description" content="Personal website of Michael Cheng.">

    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><style>text{fill:black;dominant-baseline:middle;text-anchor:middle;font-family:'IBM Plex Mono',monospace}@media(prefers-color-scheme:dark){text{fill:white}}</style><text y=%2290%22 font-size=%22140%22 x=%2250%22>*</text></svg>">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;600&display=swap" rel="stylesheet">

    <style>
        :root {
            /* LIGHT MODE COLORS */
            --bg: #f8f6f3;
            --headings: #7c7c7a;
            --text: #1f1f1f;
            --link: #e67629;
            --link-hover: #fff;
        }

        body.dark-mode {
            /* DARK MODE COLORS */
            --bg: #000000;
            --headings: #7c7c7a;
            --text: #cccccc;
            --link: #db9456;
            --link-hover: #000000;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background-color: var(--bg);
            color: var(--text);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 14px;
            line-height: 1.6;
            
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 2rem;
            
            overflow-x: hidden;
            user-select: text; 
        }

        main {
            max-width: 520px;
            width: 100%;
            text-align: left;
            position: relative;
            /* Z-index 10 puts content above the snow but allows blending */
            z-index: 10; 
        }

        h1 {
            color: var(--headings);
            font-size: 14px;
            font-weight: normal;
            margin-bottom: 2rem;
        }

        p {
            margin-bottom: 2rem;
        }

        ul {
            list-style: none;
            margin-bottom: 2rem;
        }

        li {
            margin-bottom: 0.5rem;
        }

        a {
            color: var(--link);
            text-decoration: underline;
            cursor: pointer;
        }

        a:hover {
            background-color: var(--link);
            color: var(--link-hover);
            text-decoration: none;
        }

        /* BUTTONS */
        .corner-btn {
            position: fixed;
            bottom: 2rem;
            background: none;
            border: none;
            color: var(--text);
            font-family: inherit;
            font-size: 14px;
            cursor: pointer;
            text-decoration: underline;
            padding: 0.5rem;
            opacity: 0.7;
            z-index: 20;
            user-select: none; /* Keep UI buttons unselectable */
        }

        .corner-btn:hover {
            color: var(--headings);
            opacity: 1;
        }

        .corner-btn:active {
            color: var(--headings);
        }

        #theme-toggle { right: 2rem; }
        #ripple-trigger { left: 2rem; }

        /* Hide Snow button on Mobile */
        @media (max-width: 768px) {
            #ripple-trigger {
                display: none;
            }
        }

        /* DOM SNOW CONTAINER */
        #ripple-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass through */
            z-index: 1;
            overflow: hidden;
            font-family: Menlo, Monaco, Consolas, "Courier New", monospace;
            font-size: 14px;
            line-height: 1.6;
            color: var(--text);
        }

        /* The individual snow characters */
        .ripple-char {
            position: absolute;
            pointer-events: auto;
            user-select: text;
        }

    </style>
</head>
<body>

    <div id="ripple-container"></div>

    <main id="content-block">
        <h1>Michael Cheng</h1>

        <p>
            Aerospace engineering student at TUM, focused on building systems, apps, and tools that work efficiently and elegantly.
Over the past years, I've developed iOS applications in Swift, created 3D models and prototypes in Blender, and worked on projects that bridge engineering, software, and design. I value clear solutions, attention to detail, and approaches that scale from concept to implementation.
        </p>

        <ul>
            <li>
                <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#109;&#101;&#64;&#109;&#105;&#99;&#104;&#97;&#101;&#108;&#99;&#104;&#101;&#110;&#103;&#46;&#100;&#101;&#118;">Email</a>
            </li>
            <li>
                <a href="https://github.com/michaelchengdev">GitHub</a>
            </li>
            <li>
                <a href="https://www.linkedin.com/in/michaelchengdev/">LinkedIn</a>
            </li>
        </ul>

        <p>
            Interests: aviation, space systems, astronomy, 3D modeling, software development and open-source tools.
        </p>

        <p id="last-updated" style="margin-top: 3rem; opacity: 0.5;">
            <!-- Will be populated by JavaScript -->
        </p>
    </main>

    <button id="ripple-trigger" class="corner-btn">snow</button>
    <button id="theme-toggle" class="corner-btn">dark</button>

    <script>
        // --- LAST UPDATED TIMESTAMP ---
        const lastModified = new Date(document.lastModified);
        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        const year = lastModified.getFullYear();
        const month = monthNames[lastModified.getMonth()];
        const day = lastModified.getDate();
        let hours = lastModified.getHours();
        const minutes = String(lastModified.getMinutes()).padStart(2, '0');
        const ampm = hours >= 12 ? 'PM' : 'AM';
        hours = String(hours % 12 || 12).padStart(2, '0');
        const timezoneOffset = -lastModified.getTimezoneOffset() / 60;
        const timezoneStr = timezoneOffset >= 0 ? `GMT+${timezoneOffset}` : `GMT${timezoneOffset}`;
        
        document.getElementById('last-updated').textContent = `Last updated: ${month} ${day} ${year}, ${hours}:${minutes} ${ampm} [${timezoneStr}]`;

        // --- THEME LOGIC ---
        const toggleButton = document.getElementById('theme-toggle');
        const body = document.body;

        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            body.classList.add('dark-mode');
            toggleButton.textContent = 'light';
        }

        toggleButton.addEventListener('click', () => {
            body.classList.toggle('dark-mode');
            toggleButton.textContent = body.classList.contains('dark-mode') ? 'light' : 'dark';
        });

        // --- DOM-BASED SNOW ENGINE ---
        const container = document.getElementById('ripple-container');
        const triggerBtn = document.getElementById('ripple-trigger');
        const contentBlock = document.getElementById('content-block');
        
        // Snowflake characters
        const SNOWFLAKES = ['*'];
        
        // GRID SETTINGS - must match actual monospace character dimensions
        const FONT_SIZE = 14; 
        const LINE_HEIGHT = 1.6;
        const CELL_HEIGHT = FONT_SIZE * LINE_HEIGHT; // 22.4px
        const CELL_WIDTH = FONT_SIZE * 0.6; // 8.4px for monospace
        
        let snowflakes = [];
        let w = window.innerWidth;
        let h = window.innerHeight;
        
        // --- OBJECT POOL (Optimization) ---
        const MAX_PARTICLES = 50; 
        const spanPool = [];
        
        // Initialize Pool of spans
        for (let i = 0; i < MAX_PARTICLES; i++) {
            const span = document.createElement('span');
            span.className = 'ripple-char';
            span.style.opacity = '0'; 
            container.appendChild(span);
            spanPool.push(span);
        }

        // CONTROL VARIABLES
        let isSnowing = false;
        let spawnRate = 0;          
        let maxSpawnRate = 0.2;      
        let rampUpSpeed = 0.01;      
        let rampDownSpeed = 0.005;    

        window.addEventListener('resize', () => {
            w = window.innerWidth;
            h = window.innerHeight;
        });

        class Snowflake {
            constructor() {
                this.x = Math.random() * w;
                this.y = -CELL_HEIGHT * 2; // Start well above screen
                this.char = SNOWFLAKES[Math.floor(Math.random() * SNOWFLAKES.length)];
                
                // Varied falling speeds
                this.speed = 0.5 + Math.random() * 1.5;
                
                // Gentle horizontal drift
                this.drift = (Math.random() - 0.5) * 0.5;
                
                // Slight rotation effect
                this.wobble = Math.random() * Math.PI * 2;
                this.wobbleSpeed = (Math.random() - 0.5) * 0.02;
                
                // Single opacity for all
                this.opacity = 1.0;
                
                this.isDead = false;
                this.despawnTime = null;
            }

            update() {
                // Handle despawn timer
                if (this.despawnTime !== null) {
                    if (Date.now() >= this.despawnTime) {
                        this.isDead = true;
                        return;
                    }
                }
                
                this.y += this.speed;
                this.wobble += this.wobbleSpeed;
                this.x += this.drift + Math.sin(this.wobble) * 0.3;
                
                // Remove if off screen
                if (this.y > h + 20 || this.x < -20 || this.x > w + 20) {
                    this.isDead = true;
                }
            }
            
            startDespawn() {
                if (this.despawnTime === null) {
                    // Random time between 0 and 2000ms from now
                    const randomDelay = Math.random() * 2000;
                    this.despawnTime = Date.now() + randomDelay;
                }
            }
            
            getGridKey(col, row) {
                return `${col},${row}`;
            }
        }

        // Interaction Handlers
        let releaseTimeout = null;
        
        triggerBtn.addEventListener('mousedown', () => { 
            isSnowing = true;
            // Clear any pending release timeout
            if (releaseTimeout) {
                clearTimeout(releaseTimeout);
                releaseTimeout = null;
            }
        });
        
        const handleRelease = () => {
            isSnowing = false;
            spawnRate = 0; // Immediately stop spawning
            // Immediately start despawn for ALL existing snowflakes
            if (snowflakes.length > 0) {
                snowflakes.forEach(flake => {
                    if (!flake.isDead) {
                        flake.startDespawn();
                    }
                });
            }
        };
        
        triggerBtn.addEventListener('mouseup', handleRelease);
        triggerBtn.addEventListener('mouseleave', () => {
            if (isSnowing) {
                handleRelease();
            }
        });
        triggerBtn.addEventListener('click', () => { 
            spawnRate = Math.min(spawnRate + 0.15, maxSpawnRate);
        });

        // --- MAIN ANIMATION LOOP ---
        function animate() {
            // 1. Ramp Rate Logic
            if (isSnowing) {
                if (spawnRate < maxSpawnRate) spawnRate += rampUpSpeed;
            } else {
                if (spawnRate > 0) spawnRate -= rampDownSpeed;
            }
            if (spawnRate < 0) spawnRate = 0;

            // 2. Spawn Logic
            if (spawnRate > 0 && snowflakes.length < MAX_PARTICLES) {
                const spawnCount = Math.floor(spawnRate);
                const fractional = spawnRate - spawnCount;
                
                for (let i = 0; i < spawnCount; i++) {
                    if (snowflakes.length >= MAX_PARTICLES) break;
                    const newFlake = new Snowflake();
                    snowflakes.push(newFlake);
                    // If we're not actively snowing, immediately mark for despawn
                    if (!isSnowing) {
                        newFlake.startDespawn();
                    }
                }
                
                if (Math.random() < fractional && snowflakes.length < MAX_PARTICLES) {
                    const newFlake = new Snowflake();
                    snowflakes.push(newFlake);
                    // If we're not actively snowing, immediately mark for despawn
                    if (!isSnowing) {
                        newFlake.startDespawn();
                    }
                }
            }

            // Filter out dead snowflakes BEFORE rendering
            snowflakes = snowflakes.filter(s => !s.isDead);
            
            // 3. Render Phase
            let poolIndex = 0;
            const contentRect = contentBlock.getBoundingClientRect();
            
            snowflakes.forEach(flake => {
                flake.update();
                
                if (flake.isDead) return;
                if (poolIndex >= MAX_PARTICLES) return;

                // SNAP TO GRID
                const col = Math.floor(flake.x / CELL_WIDTH);
                const row = Math.floor(flake.y / CELL_HEIGHT);
                
                // Skip if way off screen bottom
                if (flake.y > h + 20) return;
                
                const snappedX = col * CELL_WIDTH;
                const snappedY = row * CELL_HEIGHT;

                // Content collision check (snowflakes pass through content)
                const isOverContent = flake.x > contentRect.left - 20 && 
                                     flake.x < contentRect.right + 20 &&
                                     flake.y > contentRect.top - 20 && 
                                     flake.y < contentRect.bottom + 20;

                // Grab span from pool
                const span = spanPool[poolIndex];
                poolIndex++;

                // Apply position using top/left instead of transform
                span.style.top = snappedY + 'px';
                span.style.left = snappedX + 'px';
                span.textContent = flake.char;
                span.style.opacity = isOverContent ? flake.opacity * 0.3 : flake.opacity;
            });

            // 4. Cleanup Unused Spans
            for (let i = poolIndex; i < spanPool.length; i++) {
                spanPool[i].style.opacity = '0';
            }

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>

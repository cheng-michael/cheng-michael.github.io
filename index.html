<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>michael cheng</title>
    <meta name="description" content="Personal website of Michael Cheng.">

    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><style>text{fill:black}@media(prefers-color-scheme:dark){text{fill:white}}</style><text y=%22.9em%22 font-size=%2290%22 font-family=%22monospace%22>m</text></svg>">

    <style>
        :root {
            /* LIGHT MODE COLORS */
            --bg: #ffffff;
            --headings: #000000;
            --text: #555555;
            --btn-active: #000000;
        }

        body.dark-mode {
            /* DARK MODE COLORS */
            --bg: #111111;
            --headings: #ffffff;
            --text: #a0a0a0;
            --btn-active: #ffffff;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background-color: var(--bg);
            color: var(--text);
            /* Monospace Stack */
            font-family: Menlo, Monaco, Consolas, "Courier New", monospace;
            font-size: 14px;
            line-height: 1.6;
            text-transform: lowercase;
            
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 2rem;
            
            transition: background-color 0.3s, color 0.3s;
            overflow-x: hidden;
            
            /* ALLOW SELECTION of text */
            user-select: text; 
        }

        main {
            max-width: 520px;
            width: 100%;
            text-align: left;
            position: relative;
            /* Z-index 10 puts content above the snow but allows blending */
            z-index: 10; 
        }

        h1 {
            color: var(--headings);
            font-size: 14px;
            font-weight: normal;
            margin-bottom: 2rem;
        }

        p {
            margin-bottom: 2rem;
        }

        ul {
            list-style: none;
            margin-bottom: 2rem;
        }

        li {
            margin-bottom: 0.5rem;
        }

        a {
            color: inherit;
            text-decoration: underline;
            cursor: pointer;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--headings);
            text-decoration: underline; /* Standard underline on hover */
        }

        /* BUTTONS */
        .corner-btn {
            position: fixed;
            bottom: 2rem;
            background: none;
            border: none;
            color: var(--text);
            font-family: inherit;
            font-size: 14px;
            cursor: pointer;
            text-decoration: underline;
            padding: 0.5rem;
            opacity: 0.7;
            z-index: 20;
            user-select: none; /* Keep UI buttons unselectable */
        }

        .corner-btn:hover {
            color: var(--headings);
            opacity: 1;
        }

        .corner-btn:active {
            color: var(--headings);
        }

        #theme-toggle { right: 2rem; }
        #ripple-trigger { left: 2rem; }

        /* Hide Snow button on Mobile */
        @media (max-width: 768px) {
            #ripple-trigger {
                display: none;
            }
        }

        /* DOM SNOW CONTAINER */
        #ripple-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass through */
            z-index: 1;
            overflow: hidden;
            font-family: Menlo, Monaco, Consolas, "Courier New", monospace;
            font-size: 14px;
            line-height: 1.6;
            color: var(--text);
        }

        /* The individual snow characters */
        .ripple-char {
            position: absolute;
            pointer-events: auto;
            user-select: text;
        }

    </style>
</head>
<body>

    <div id="ripple-container"></div>

    <main id="content-block">
        <h1>michael cheng</h1>

        <p>
            lorem ipsum dolor sit amet, consectetur adipiscing elit. sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
        </p>

        <ul>
            <li>
                <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#109;&#101;&#64;&#109;&#105;&#99;&#104;&#97;&#101;&#108;&#99;&#104;&#101;&#110;&#103;&#46;&#100;&#101;&#118;">email</a>
            </li>
            <li>
                <a href="https://github.com/michaelchengdev">github</a>
            </li>
            <li>
                <a href="https://www.linkedin.com/in/michaelchengdev/">linkedin</a>
            </li>
        </ul>

        <p>
            viverra ipsum nunc aliquet bibendum enim facilisis gravida neque convallis.
        </p>
    </main>

    <button id="ripple-trigger" class="corner-btn">snow</button>
    <button id="theme-toggle" class="corner-btn">dark</button>

    <script>
        // --- THEME LOGIC ---
        const toggleButton = document.getElementById('theme-toggle');
        const body = document.body;

        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            body.classList.add('dark-mode');
            toggleButton.textContent = 'light';
        }

        toggleButton.addEventListener('click', () => {
            body.classList.toggle('dark-mode');
            toggleButton.textContent = body.classList.contains('dark-mode') ? 'light' : 'dark';
        });

        // --- DOM-BASED SNOW ENGINE ---
        const container = document.getElementById('ripple-container');
        const triggerBtn = document.getElementById('ripple-trigger');
        const contentBlock = document.getElementById('content-block');
        
        // Snowflake characters
        const SNOWFLAKES = ['*'];
        
        // GRID SETTINGS - must match actual monospace character dimensions
        const FONT_SIZE = 14; 
        const LINE_HEIGHT = 1.6;
        const CELL_HEIGHT = FONT_SIZE * LINE_HEIGHT; // 22.4px
        const CELL_WIDTH = FONT_SIZE * 0.6; // 8.4px for monospace
        
        let snowflakes = [];
        let occupiedCells = new Set(); // Track occupied grid positions
        let w = window.innerWidth;
        let h = window.innerHeight;
        
        // --- OBJECT POOL (Optimization) ---
        const MAX_PARTICLES = 50; 
        const spanPool = [];
        
        // Initialize Pool of spans
        for (let i = 0; i < MAX_PARTICLES; i++) {
            const span = document.createElement('span');
            span.className = 'ripple-char';
            span.style.opacity = '0'; 
            container.appendChild(span);
            spanPool.push(span);
        }

        // CONTROL VARIABLES
        let isSnowing = false;
        let spawnRate = 0;          
        let maxSpawnRate = 0.2;      
        let rampUpSpeed = 0.01;      
        let rampDownSpeed = 0.005;    

        window.addEventListener('resize', () => {
            w = window.innerWidth;
            h = window.innerHeight;
        });

        class Snowflake {
            constructor() {
                this.x = Math.random() * w;
                this.y = -20;
                this.char = SNOWFLAKES[Math.floor(Math.random() * SNOWFLAKES.length)];
                
                // Varied falling speeds
                this.speed = 0.5 + Math.random() * 1.5;
                
                // Gentle horizontal drift
                this.drift = (Math.random() - 0.5) * 0.5;
                
                // Slight rotation effect
                this.wobble = Math.random() * Math.PI * 2;
                this.wobbleSpeed = (Math.random() - 0.5) * 0.02;
                
                // Single opacity for all
                this.opacity = 1.0;
                
                this.isDead = false;
                this.gridKey = null; // Track current grid position
                this.despawnTime = null; // When to despawn (null = not despawning)
            }

            update() {
                // Handle despawn timer
                if (this.despawnTime !== null) {
                    if (Date.now() >= this.despawnTime) {
                        this.isDead = true;
                        if (this.gridKey) {
                            occupiedCells.delete(this.gridKey);
                            this.gridKey = null;
                        }
                        return;
                    }
                }
                
                this.y += this.speed;
                this.wobble += this.wobbleSpeed;
                this.x += this.drift + Math.sin(this.wobble) * 0.3;
                
                // Remove if off screen
                if (this.y > h + 20 || this.x < -20 || this.x > w + 20) {
                    this.isDead = true;
                    if (this.gridKey) {
                        occupiedCells.delete(this.gridKey);
                        this.gridKey = null;
                    }
                }
            }
            
            startDespawn() {
                if (this.despawnTime === null) {
                    // Random time between 0 and 2000ms from now
                    const randomDelay = Math.random() * 2000;
                    this.despawnTime = Date.now() + randomDelay;
                }
            }
            
            getGridKey(col, row) {
                return `${col},${row}`;
            }
        }

        // Interaction Handlers
        let wasSnowing = false;
        let releaseTimeout = null;
        
        triggerBtn.addEventListener('mousedown', () => { 
            isSnowing = true;
            wasSnowing = true;
            // Clear any pending release timeout
            if (releaseTimeout) {
                clearTimeout(releaseTimeout);
                releaseTimeout = null;
            }
        });
        
        const handleRelease = () => {
            isSnowing = false;
            // Wait a bit to see if any snowflakes actually spawned
            releaseTimeout = setTimeout(() => {
                // Start despawn for all existing snowflakes
                snowflakes.forEach(flake => flake.startDespawn());
                wasSnowing = false;
                releaseTimeout = null;
            }, 100);
        };
        
        triggerBtn.addEventListener('mouseup', handleRelease);
        triggerBtn.addEventListener('mouseleave', () => {
            if (isSnowing) {
                handleRelease();
            }
        });
        triggerBtn.addEventListener('click', () => { 
            spawnRate = Math.min(spawnRate + 0.15, maxSpawnRate);
            wasSnowing = true;
        });

        // --- MAIN ANIMATION LOOP ---
        function animate() {
            // 1. Ramp Rate Logic
            if (isSnowing) {
                if (spawnRate < maxSpawnRate) spawnRate += rampUpSpeed;
            } else {
                if (spawnRate > 0) spawnRate -= rampDownSpeed;
            }
            if (spawnRate < 0) spawnRate = 0;

            // 2. Spawn Logic
            if (spawnRate > 0) {
                const spawnCount = Math.floor(spawnRate);
                const fractional = spawnRate - spawnCount;
                
                for (let i = 0; i < spawnCount; i++) {
                    snowflakes.push(new Snowflake());
                }
                
                if (Math.random() < fractional) {
                    snowflakes.push(new Snowflake());
                }
            }

            snowflakes = snowflakes.filter(s => !s.isDead);
            
            // 3. Render Phase
            let poolIndex = 0;
            const contentRect = contentBlock.getBoundingClientRect();
            
            // Clear ALL occupied cells at the start of each frame
            occupiedCells.clear();
            
            snowflakes.forEach(flake => {
                flake.update();
                
                if (flake.isDead) return;
                if (poolIndex >= MAX_PARTICLES) return;

                // SNAP TO GRID
                const col = Math.floor(flake.x / CELL_WIDTH);
                const row = Math.floor(flake.y / CELL_HEIGHT);
                const gridKey = flake.getGridKey(col, row);
                
                // Skip if this grid cell is already occupied THIS FRAME
                if (occupiedCells.has(gridKey)) {
                    return;
                }
                
                // Mark cell as occupied for this frame
                occupiedCells.add(gridKey);
                flake.gridKey = gridKey;
                
                const snappedX = col * CELL_WIDTH;
                const snappedY = row * CELL_HEIGHT;

                // Content collision check (snowflakes pass through content)
                const isOverContent = flake.x > contentRect.left - 20 && 
                                     flake.x < contentRect.right + 20 &&
                                     flake.y > contentRect.top - 20 && 
                                     flake.y < contentRect.bottom + 20;

                // Grab span from pool
                const span = spanPool[poolIndex];
                poolIndex++;

                // Apply position using top/left instead of transform
                span.style.top = snappedY + 'px';
                span.style.left = snappedX + 'px';
                span.textContent = flake.char;
                span.style.opacity = isOverContent ? flake.opacity * 0.3 : flake.opacity;
            });

            // 4. Cleanup Unused Spans
            for (let i = poolIndex; i < MAX_PARTICLES; i++) {
                spanPool[i].style.opacity = '0';
            }

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>

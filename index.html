<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>michael cheng</title>
    <meta name="description" content="Personal website of Michael Cheng.">

    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><style>text{fill:black}@media(prefers-color-scheme:dark){text{fill:white}}</style><text y=%22.9em%22 font-size=%2290%22 font-family=%22monospace%22>m</text></svg>">

    <style>
        :root {
            /* LIGHT MODE COLORS */
            --bg: #ffffff;
            --headings: #000000;
            --text: #555555;
            --btn-active: #000000;
        }

        body.dark-mode {
            /* DARK MODE COLORS */
            --bg: #111111;
            --headings: #ffffff;
            --text: #a0a0a0;
            --btn-active: #ffffff;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background-color: var(--bg);
            color: var(--text);
            /* Monospace Stack */
            font-family: Menlo, Monaco, Consolas, "Courier New", monospace;
            font-size: 14px;
            line-height: 1.6;
            text-transform: lowercase;
            
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 2rem;
            
            transition: background-color 0.3s, color 0.3s;
            overflow-x: hidden;
            
            /* ALLOW SELECTION of text */
            user-select: text; 
        }

        main {
            max-width: 520px;
            width: 100%;
            text-align: left;
            position: relative;
            /* Z-index 10 puts content above the rain but allows blending */
            z-index: 10; 
        }

        h1 {
            color: var(--headings);
            font-size: 14px;
            font-weight: normal;
            margin-bottom: 2rem;
        }

        p {
            margin-bottom: 2rem;
        }

        ul {
            list-style: none;
            margin-bottom: 2rem;
        }

        li {
            margin-bottom: 0.5rem;
        }

        a {
            color: inherit;
            text-decoration: underline;
            cursor: pointer;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--headings);
            text-decoration: underline; /* Standard underline on hover */
        }

        /* BUTTONS */
        .corner-btn {
            position: fixed;
            bottom: 2rem;
            background: none;
            border: none;
            color: var(--text);
            font-family: inherit;
            font-size: 14px;
            cursor: pointer;
            text-decoration: underline;
            padding: 0.5rem;
            opacity: 0.7;
            z-index: 20;
            user-select: none; /* Keep UI buttons unselectable */
        }

        .corner-btn:hover {
            color: var(--headings);
            opacity: 1;
        }

        .corner-btn:active {
            color: var(--headings);
        }

        #theme-toggle { right: 2rem; }
        #ripple-trigger { left: 2rem; }

        /* Hide Rain button on Mobile */
        @media (max-width: 768px) {
            #ripple-trigger {
                display: none;
            }
        }

        /* DOM RIPPLE CONTAINER */
        #ripple-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass through */
            z-index: 1;
            overflow: hidden;
        }

        /* The individual ripple characters */
        .ripple-char {
            position: absolute;
            pointer-events: auto; /* Allow selecting the rain text */
            user-select: text;
            will-change: transform, opacity;
            white-space: pre; 
        }

    </style>
</head>
<body>

    <div id="ripple-container"></div>

    <main id="content-block">
        <h1>michael cheng</h1>

        <p>
            lorem ipsum dolor sit amet, consectetur adipiscing elit. sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
        </p>

        <ul>
            <li>
                <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#109;&#101;&#64;&#109;&#105;&#99;&#104;&#97;&#101;&#108;&#99;&#104;&#101;&#110;&#103;&#46;&#100;&#101;&#118;">email</a>
            </li>
            <li>
                <a href="https://github.com/michaelchengdev">github</a>
            </li>
            <li>
                <a href="https://www.linkedin.com/in/michaelchengdev/">linkedin</a>
            </li>
        </ul>

        <p>
            viverra ipsum nunc aliquet bibendum enim facilisis gravida neque convallis.
        </p>
    </main>

    <button id="ripple-trigger" class="corner-btn">rain</button>
    <button id="theme-toggle" class="corner-btn">dark</button>

    <script>
        // --- THEME LOGIC ---
        const toggleButton = document.getElementById('theme-toggle');
        const body = document.body;

        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            body.classList.add('dark-mode');
            toggleButton.textContent = 'light';
        }

        toggleButton.addEventListener('click', () => {
            body.classList.toggle('dark-mode');
            toggleButton.textContent = body.classList.contains('dark-mode') ? 'light' : 'dark';
        });

        // --- DOM-BASED RAIN ENGINE ---
        const container = document.getElementById('ripple-container');
        const triggerBtn = document.getElementById('ripple-trigger');
        const contentBlock = document.getElementById('content-block');
        
        // Character sets for different densities
        const DENSITY_TIERS = [
            ['@', '#', 'O', '0', '8', '&'], 
            ['o', '*', 'x', '%', 'z'],
            ['+', '=', '~', '-', '^'],
            ['.', ',', '\'', '`', '_']      
        ];
        
        // GRID SETTINGS (Must match CSS)
        const FONT_SIZE = 14; 
        const LINE_HEIGHT = 1.6;
        const CELL_HEIGHT = FONT_SIZE * LINE_HEIGHT; 
        const CELL_WIDTH = FONT_SIZE * 0.6; 
        
        let drops = [];
        let w = window.innerWidth;
        let h = window.innerHeight;
        
        // --- OBJECT POOL (Optimization) ---
        const MAX_PARTICLES = 400; 
        const spanPool = [];
        
        // Initialize Pool of spans
        for (let i = 0; i < MAX_PARTICLES; i++) {
            const span = document.createElement('span');
            span.className = 'ripple-char';
            span.style.opacity = '0'; 
            container.appendChild(span);
            spanPool.push(span);
        }

        // CONTROL VARIABLES
        let isHolding = false;
        let spawnRate = 0;          
        let maxSpawnRate = 1.5;      
        let rampUpSpeed = 0.05;      
        let rampDownSpeed = 0.02;    

        window.addEventListener('resize', () => {
            w = window.innerWidth;
            h = window.innerHeight;
        });

        class RealisticDrop {
            constructor() {
                const rect = contentBlock.getBoundingClientRect();
                const padding = 50; 
                const side = Math.random() > 0.5 ? 'left' : 'right';
                
                if (side === 'left') {
                    this.x = Math.random() * (rect.left - padding);
                } else {
                    this.x = (rect.right + padding) + Math.random() * (w - (rect.right + padding));
                }
                this.y = Math.random() * h;
                
                const r = Math.random();
                if (r < 0.60) {
                    this.type = 'small';
                } else if (r < 0.90) {
                    this.type = 'medium';
                } else {
                    this.type = 'large';
                }

                this.age = 0;
                this.isDead = false;
                this.friction = 0.96; 
                this.radius = 0;

                if (this.type === 'small') {
                    this.maxAge = 50 + Math.random() * 20;  
                    this.velocity = 1.5 + Math.random();    
                    this.waveLength = 8 + Math.random() * 4;
                    this.maxIntensity = 0.5;                
                } else if (this.type === 'medium') {
                    this.maxAge = 80 + Math.random() * 30;
                    this.velocity = 2.0 + Math.random();
                    this.waveLength = 14 + Math.random() * 5;
                    this.maxIntensity = 0.8;                
                } else { 
                    this.maxAge = 120 + Math.random() * 40; 
                    this.velocity = 2.8 + Math.random();    
                    this.waveLength = 22 + Math.random() * 8; 
                    this.maxIntensity = 1.0;                
                }
            }

            update() {
                this.age++;
                this.radius += this.velocity;
                if (this.velocity > 0.2) this.velocity *= this.friction;
                if (this.age > this.maxAge) this.isDead = true;
            }

            getRings() {
                const rings = [];
                let progress = this.age / this.maxAge;
                let baseIntensity = this.maxIntensity * (1 - progress);
                if (baseIntensity <= 0) return [];

                for (let i = 0; i < 3; i++) {
                    const offset = i * this.waveLength;
                    const r = this.radius - offset;
                    if (r <= 0) continue;

                    let ringIntensity = baseIntensity * (1 - (i * 0.3));
                    ringIntensity *= (60 / (r + 60)); 

                    if (ringIntensity > 0.05) {
                        rings.push({ r: r, intensity: ringIntensity });
                    }
                }
                return rings;
            }
        }

        // Interaction Handlers
        triggerBtn.addEventListener('mousedown', () => { isHolding = true; });
        triggerBtn.addEventListener('mouseup', () => { isHolding = false; });
        triggerBtn.addEventListener('mouseleave', () => { isHolding = false; });
        triggerBtn.addEventListener('click', () => { spawnRate = Math.min(spawnRate + 1, maxSpawnRate); });

        // --- MAIN ANIMATION LOOP ---
        function animate() {
            // 1. Ramp Rate Logic
            if (isHolding) {
                if (spawnRate < maxSpawnRate) spawnRate += rampUpSpeed;
            } else {
                if (spawnRate > 0) spawnRate -= rampDownSpeed;
            }
            if (spawnRate < 0) spawnRate = 0;

            // 2. Spawn Logic
            if (spawnRate > 0) {
                const chance = Math.random() * 10;
                if (chance < spawnRate) drops.push(new RealisticDrop());
            }

            drops = drops.filter(d => !d.isDead);
            
            // 3. Render Phase
            let poolIndex = 0;
            const contentRect = contentBlock.getBoundingClientRect();
            
            drops.forEach(drop => {
                drop.update();
                const rings = drop.getRings();

                rings.forEach(ring => {
                    if (poolIndex >= MAX_PARTICLES) return;

                    let safeIntensity = Math.max(0, Math.min(1, ring.intensity));
                    let tierIndex = Math.floor((1 - safeIntensity) * DENSITY_TIERS.length);
                    tierIndex = Math.max(0, Math.min(DENSITY_TIERS.length - 1, tierIndex));
                    
                    const charSet = DENSITY_TIERS[tierIndex];
                    const alpha = safeIntensity < 0.3 ? safeIntensity * 3 : 1;

                    const circumference = 2 * Math.PI * ring.r;
                    // Density modifier based on drop size
                    const densityMod = drop.type === 'small' ? 1.5 : 1.2;
                    const steps = Math.floor(circumference / (CELL_WIDTH * densityMod));
                    
                    for (let i = 0; i < steps; i++) {
                        if (poolIndex >= MAX_PARTICLES) break;

                        const angle = (i / steps) * Math.PI * 2;
                        
                        // Raw coordinates
                        const rawX = drop.x + Math.cos(angle) * ring.r;
                        const rawY = drop.y + Math.sin(angle) * ring.r;

                        // Bounds check
                        if (rawX < 0 || rawX > w || rawY < 0 || rawY > h) continue;

                        // Content collision check
                        if (rawX > contentRect.left - 20 && rawX < contentRect.right + 20 &&
                            rawY > contentRect.top - 20 && rawY < contentRect.bottom + 20) {
                            continue;
                        }

                        // SNAP TO GRID
                        const col = Math.floor(rawX / CELL_WIDTH);
                        const row = Math.floor(rawY / CELL_HEIGHT);
                        const snappedX = col * CELL_WIDTH;
                        const snappedY = row * CELL_HEIGHT + (CELL_HEIGHT - FONT_SIZE)/2;

                        // Grab span from pool
                        const span = spanPool[poolIndex];
                        poolIndex++;

                        // Stable char selection based on grid position
                        const hash = col + row; 
                        const selectedChar = charSet[hash % charSet.length];

                        // Apply styles
                        span.style.transform = `translate3d(${snappedX}px, ${snappedY}px, 0)`;
                        span.textContent = selectedChar;
                        span.style.opacity = alpha;
                        
                        const isDark = body.classList.contains('dark-mode');
                        span.style.color = isDark ? `rgba(255, 255, 255, 1)` : `rgba(0, 0, 0, 1)`;
                    }
                });
            });

            // 4. Cleanup Unused Spans
            for (let i = poolIndex; i < MAX_PARTICLES; i++) {
                spanPool[i].style.opacity = '0';
            }

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>

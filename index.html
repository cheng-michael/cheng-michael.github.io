<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>michael cheng</title>
    <style>
        :root {
            /* LIGHT MODE */
            --bg: #ffffff;
            --headings: #000000;
            --text: #555555;
            --btn-active: #000000;
        }

        body.dark-mode {
            /* DARK MODE */
            --bg: #111111;
            --headings: #ffffff;
            --text: #a0a0a0;
            --btn-active: #ffffff;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background-color: var(--bg);
            color: var(--text);
            font-family: Menlo, Monaco, Consolas, "Courier New", monospace;
            font-size: 14px;
            line-height: 1.6;
            text-transform: lowercase;
            
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 2rem;
            
            transition: background-color 0.3s, color 0.3s;
            overflow-x: hidden;
            user-select: none; 
        }

        main {
            max-width: 520px;
            width: 100%;
            text-align: left;
            position: relative;
            z-index: 10; 
        }

        h1 {
            color: var(--headings);
            font-size: 14px;
            font-weight: normal;
            margin-bottom: 2rem;
        }

        p {
            margin-bottom: 2rem;
        }

        ul {
            list-style: none;
            margin-bottom: 2rem;
        }

        li {
            margin-bottom: 0.5rem;
        }

        a {
            color: inherit;
            text-decoration: underline;
            cursor: pointer;
            transition: color 0.2s;
        }

        /* FIXED: Hover no longer creates a double line, just changes color */
        a:hover {
            color: var(--headings);
            text-decoration: underline; 
        }

        /* BUTTONS */
        .corner-btn {
            position: fixed;
            bottom: 2rem;
            background: none;
            border: none;
            color: var(--text);
            font-family: inherit;
            font-size: 14px;
            cursor: pointer;
            text-decoration: underline;
            padding: 0.5rem;
            opacity: 0.7;
            z-index: 20;
        }

        .corner-btn:hover {
            color: var(--headings);
            opacity: 1;
        }

        .corner-btn:active {
            color: var(--headings);
        }

        #theme-toggle { right: 2rem; }
        #ripple-trigger { left: 2rem; }

        /* FIXED: Hide Rain button on Mobile */
        @media (max-width: 768px) {
            #ripple-trigger {
                display: none;
            }
        }

        canvas#ascii-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 1;
        }
    </style>
</head>
<body>

    <canvas id="ascii-overlay"></canvas>

    <main id="content-block">
        <h1>michael cheng</h1>

        <p>
            lorem ipsum dolor sit amet, consectetur adipiscing elit. sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
        </p>

        <ul>
            <li>
                <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#109;&#101;&#64;&#109;&#105;&#99;&#104;&#97;&#101;&#108;&#99;&#104;&#101;&#110;&#103;&#46;&#100;&#101;&#118;">email</a>
            </li>
            <li>
                <a href="https://github.com/michaelchengdev">github</a>
            </li>
            <li>
                <a href="https://www.linkedin.com/in/michaelchengdev/">linkedin</a>
            </li>
        </ul>

        <p>
            viverra ipsum nunc aliquet bibendum enim facilisis gravida neque convallis.
        </p>
    </main>

    <button id="ripple-trigger" class="corner-btn">rain</button>
    <button id="theme-toggle" class="corner-btn">dark</button>

    <script>
        const toggleButton = document.getElementById('theme-toggle');
        const body = document.body;

        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            body.classList.add('dark-mode');
            toggleButton.textContent = 'light';
        }

        toggleButton.addEventListener('click', () => {
            body.classList.toggle('dark-mode');
            toggleButton.textContent = body.classList.contains('dark-mode') ? 'light' : 'dark';
        });

        // --- ASCII FLUID ENGINE v7 (Adjusted Quantities) ---
        const canvas = document.getElementById('ascii-overlay');
        const ctx = canvas.getContext('2d');
        const triggerBtn = document.getElementById('ripple-trigger');
        const contentBlock = document.getElementById('content-block');
        
        const DENSITY_TIERS = [
            ['@', '#', 'O', '0', '8', '&'], 
            ['o', '*', 'x', '%', 'z'],
            ['+', '=', '~', '-', '^'],
            ['.', ',', '\'', '`', '_']      
        ];
        
        const FONT_SIZE = 14; 
        
        let drops = [];
        let w, h;
        
        // ACCELERATOR VARIABLES
        let isHolding = false;
        let spawnRate = 0;          
        
        // ADJUSTMENT: Drastically reduced Max Rate.
        // 1.5 means roughly 15% chance per frame => ~9 drops per second max
        let maxSpawnRate = 1.5;      
        
        let rampUpSpeed = 0.05;      // Slower ramp up
        let rampDownSpeed = 0.02;    // Slower taper off

        function resize() {
            w = canvas.width = window.innerWidth;
            h = canvas.height = window.innerHeight;
            ctx.font = `${FONT_SIZE}px Menlo, Monaco, Consolas, monospace`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
        }
        window.addEventListener('resize', resize);
        resize();

        class RealisticDrop {
            constructor() {
                const rect = contentBlock.getBoundingClientRect();
                const padding = 50; 
                const side = Math.random() > 0.5 ? 'left' : 'right';
                
                if (side === 'left') {
                    this.x = Math.random() * (rect.left - padding);
                } else {
                    this.x = (rect.right + padding) + Math.random() * (w - (rect.right + padding));
                }
                this.y = Math.random() * h;
                
                const r = Math.random();
                if (r < 0.60) {
                    this.type = 'small';
                } else if (r < 0.90) {
                    this.type = 'medium';
                } else {
                    this.type = 'large';
                }

                this.age = 0;
                this.isDead = false;
                this.friction = 0.96; 
                this.radius = 0;

                if (this.type === 'small') {
                    this.maxAge = 50 + Math.random() * 20;  
                    this.velocity = 1.5 + Math.random();    
                    this.waveLength = 8 + Math.random() * 4;
                    this.maxIntensity = 0.5;                
                } else if (this.type === 'medium') {
                    this.maxAge = 80 + Math.random() * 30;
                    this.velocity = 2.0 + Math.random();
                    this.waveLength = 14 + Math.random() * 5;
                    this.maxIntensity = 0.8;                
                } else { 
                    this.maxAge = 120 + Math.random() * 40; 
                    this.velocity = 2.8 + Math.random();    
                    this.waveLength = 22 + Math.random() * 8; 
                    this.maxIntensity = 1.0;                
                }
            }

            update() {
                this.age++;
                this.radius += this.velocity;
                if (this.velocity > 0.2) this.velocity *= this.friction;
                
                if (this.age > this.maxAge) this.isDead = true;
            }

            getRings() {
                const rings = [];
                let progress = this.age / this.maxAge;
                let baseIntensity = this.maxIntensity * (1 - progress);
                
                if (baseIntensity <= 0) return [];

                for (let i = 0; i < 3; i++) {
                    const offset = i * this.waveLength;
                    const r = this.radius - offset;
                    if (r <= 0) continue;

                    let ringIntensity = baseIntensity * (1 - (i * 0.3));
                    ringIntensity *= (60 / (r + 60)); 

                    if (ringIntensity > 0.05) {
                        rings.push({ r: r, intensity: ringIntensity });
                    }
                }
                return rings;
            }
        }

        // --- INTERACTION ---
        triggerBtn.addEventListener('mousedown', () => { isHolding = true; });
        triggerBtn.addEventListener('mouseup', () => { isHolding = false; });
        triggerBtn.addEventListener('mouseleave', () => { isHolding = false; });
        
        triggerBtn.addEventListener('click', () => {
            // Tiny boost on click
            spawnRate = Math.min(spawnRate + 1, maxSpawnRate); 
        });

        // --- ANIMATION ---
        function animate() {
            ctx.clearRect(0, 0, w, h);
            
            // 1. RATE CONTROLLER
            if (isHolding) {
                if (spawnRate < maxSpawnRate) {
                    spawnRate += rampUpSpeed;
                }
            } else {
                if (spawnRate > 0) {
                    spawnRate -= rampDownSpeed;
                }
            }
            
            if (spawnRate < 0) spawnRate = 0;

            // 2. SPAWNER
            if (spawnRate > 0) {
                // Determine spawn chance based on rate (0 to 10 scale)
                const chance = Math.random() * 10;
                
                if (chance < spawnRate) {
                    drops.push(new RealisticDrop());
                }
            }

            // 3. PHYSICS
            drops = drops.filter(d => !d.isDead);

            drops.forEach(drop => {
                drop.update();
                const rings = drop.getRings();

                rings.forEach(ring => {
                    let safeIntensity = Math.max(0, Math.min(1, ring.intensity));
                    let tierIndex = Math.floor((1 - safeIntensity) * DENSITY_TIERS.length);
                    tierIndex = Math.max(0, Math.min(DENSITY_TIERS.length - 1, tierIndex));
                    
                    const charSet = DENSITY_TIERS[tierIndex];

                    const alpha = safeIntensity < 0.3 ? safeIntensity * 3 : 1;
                    const circumference = 2 * Math.PI * ring.r;
                    
                    const densityMod = drop.type === 'small' ? 1.5 : 1.2;
                    const charCount = Math.floor(circumference / (FONT_SIZE * densityMod));
                    
                    for (let i = 0; i < charCount; i++) {
                        const angle = (i / charCount) * Math.PI * 2;
                        const charX = drop.x + Math.cos(angle) * ring.r;
                        const charY = drop.y + Math.sin(angle) * ring.r;

                        if (charX < 0 || charX > w || charY < 0 || charY > h) continue;

                        const rect = contentBlock.getBoundingClientRect();
                        if (charX > rect.left - 20 && charX < rect.right + 20 &&
                            charY > rect.top - 20 && charY < rect.bottom + 20) {
                            continue;
                        }
                        
                        const hash = Math.floor(charX + charY);
                        const selectedChar = charSet[hash % charSet.length];

                        const isDark = body.classList.contains('dark-mode');
                        ctx.fillStyle = isDark 
                            ? `rgba(255, 255, 255, ${alpha})` 
                            : `rgba(0, 0, 0, ${alpha})`;
                        
                        ctx.fillText(selectedChar, charX, charY);
                    }
                });
            });

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>

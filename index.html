<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>michael cheng</title>
    <style>
        :root {
            /* LIGHT MODE */
            --bg: #ffffff;
            --headings: #000000;
            --text: #555555;
            --btn-active: #000000;
        }

        body.dark-mode {
            /* DARK MODE */
            --bg: #111111;
            --headings: #ffffff;
            --text: #a0a0a0;
            --btn-active: #ffffff;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background-color: var(--bg);
            color: var(--text);
            font-family: Menlo, Monaco, Consolas, "Courier New", monospace;
            font-size: 14px;
            line-height: 1.6;
            text-transform: lowercase;
            
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 2rem;
            
            transition: background-color 0.3s, color 0.3s;
            overflow-x: hidden;
            /* Disable selection so holding the button doesn't highlight text */
            user-select: none; 
        }

        /* The Content Block */
        main {
            max-width: 520px;
            width: 100%;
            text-align: left;
            position: relative;
            z-index: 10; 
        }

        h1 {
            color: var(--headings);
            font-size: 14px;
            font-weight: normal;
            margin-bottom: 2rem;
        }

        p {
            margin-bottom: 2rem;
        }

        ul {
            list-style: none;
            margin-bottom: 2rem;
        }

        li {
            margin-bottom: 0.5rem;
        }

        a {
            color: inherit;
            text-decoration: underline;
            cursor: pointer;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--headings);
            text-decoration-style: double;
        }

        /* BUTTONS */
        .corner-btn {
            position: fixed;
            bottom: 2rem;
            background: none;
            border: none;
            color: var(--text);
            font-family: inherit;
            font-size: 14px;
            cursor: pointer;
            text-decoration: underline;
            padding: 0.5rem;
            opacity: 0.7;
            z-index: 20;
        }

        .corner-btn:hover {
            color: var(--headings);
            opacity: 1;
        }

        /* Active state for the effect button */
        .corner-btn:active {
            color: var(--headings);
            text-decoration-style: double;
        }

        #theme-toggle { right: 2rem; }
        #ripple-trigger { left: 2rem; }

        /* CANVAS LAYER */
        canvas#ascii-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 1;
        }
    </style>
</head>
<body>

    <canvas id="ascii-overlay"></canvas>

    <main id="content-block">
        <h1>michael cheng</h1>

        <p>
            lorem ipsum dolor sit amet, consectetur adipiscing elit. sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
        </p>

        <ul>
            <li>
                <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#109;&#101;&#64;&#109;&#105;&#99;&#104;&#97;&#101;&#108;&#99;&#104;&#101;&#110;&#103;&#46;&#100;&#101;&#118;">email</a>
            </li>
            <li>
                <a href="https://github.com/michaelchengdev">github</a>
            </li>
            <li>
                <a href="https://www.linkedin.com/in/michaelchengdev/">linkedin</a>
            </li>
        </ul>

        <p>
            viverra ipsum nunc aliquet bibendum enim facilisis gravida neque convallis.
        </p>
    </main>

    <button id="ripple-trigger" class="corner-btn">effect</button>
    <button id="theme-toggle" class="corner-btn">dark</button>

    <script>
        // --- THEME TOGGLE ---
        const toggleButton = document.getElementById('theme-toggle');
        const body = document.body;

        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            body.classList.add('dark-mode');
            toggleButton.textContent = 'light';
        }

        toggleButton.addEventListener('click', () => {
            body.classList.toggle('dark-mode');
            toggleButton.textContent = body.classList.contains('dark-mode') ? 'light' : 'dark';
        });

        // --- ASCII PARTICLE PHYSICS ---
        const canvas = document.getElementById('ascii-overlay');
        const ctx = canvas.getContext('2d');
        const triggerBtn = document.getElementById('ripple-trigger');
        const contentBlock = document.getElementById('content-block');
        
        // Settings
        const CHARS = ['.', '+', '*', 'Â°', 'x', '~', '-'];
        const FONT_SIZE = 14; 
        
        let ripples = [];
        let w, h;
        let isHolding = false; // Tracks if mouse is down
        let spawnInterval; // Timer for holding down button

        function resize() {
            w = canvas.width = window.innerWidth;
            h = canvas.height = window.innerHeight;
            ctx.font = `${FONT_SIZE}px Menlo, Monaco, Consolas, monospace`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
        }
        window.addEventListener('resize', resize);
        resize();

        class SmallRipple {
            constructor() {
                // 1. Calculate Safe Zones (Left and Right of content)
                const rect = contentBlock.getBoundingClientRect();
                const padding = 40; // Space away from text
                
                // Randomly decide: Left side OR Right side?
                const side = Math.random() > 0.5 ? 'left' : 'right';
                
                if (side === 'left') {
                    // Spawn anywhere from 0 to (rect.left - padding)
                    this.x = Math.random() * (rect.left - padding);
                } else {
                    // Spawn anywhere from (rect.right + padding) to Screen Width
                    this.x = (rect.right + padding) + Math.random() * (w - (rect.right + padding));
                }

                this.y = Math.random() * h; // Any height
                
                // Physics properties
                this.startTime = Date.now();
                this.speed = 2 + Math.random() * 3; // Random expansion speed
                this.maxRadius = 50 + Math.random() * 100; // Random size (small to medium)
                this.lifespan = 1000 + Math.random() * 1000; // How long it lives (ms)
            }

            isActive() {
                return (Date.now() - this.startTime) < this.lifespan;
            }

            getCurrentState() {
                const age = Date.now() - this.startTime;
                const progress = age / this.lifespan; // 0.0 to 1.0
                
                // Radius grows
                const radius = age * (this.speed / 10);
                
                // Opacity fades out as it gets older
                // (1 - progress) means it starts at 1 and goes to 0
                const alpha = Math.max(0, 1 - progress); 

                return { radius, alpha };
            }
        }

        function spawnBurst(count) {
            for(let i=0; i<count; i++) {
                ripples.push(new SmallRipple());
            }
        }

        // --- INTERACTION HANDLERS ---
        
        // 1. Simple Click (Burst)
        triggerBtn.addEventListener('click', () => {
            spawnBurst(15);
        });

        // 2. Mouse Down (Start continuous rain)
        triggerBtn.addEventListener('mousedown', () => {
            isHolding = true;
            spawnBurst(5); // Immediate feedback
            spawnInterval = setInterval(() => {
                spawnBurst(2); // Add a few every 50ms
            }, 50);
        });

        // 3. Mouse Up/Leave (Stop rain)
        const stopSpawning = () => {
            isHolding = false;
            clearInterval(spawnInterval);
        };
        triggerBtn.addEventListener('mouseup', stopSpawning);
        triggerBtn.addEventListener('mouseleave', stopSpawning);
        
        // Also support Touch for mobile
        triggerBtn.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Stop zoom
            isHolding = true;
            spawnInterval = setInterval(() => spawnBurst(2), 50);
        });
        triggerBtn.addEventListener('touchend', stopSpawning);


        // --- ANIMATION LOOP ---
        function animate() {
            ctx.clearRect(0, 0, w, h);

            if (ripples.length > 0) {
                // Filter out dead ripples
                ripples = ripples.filter(r => r.isActive());

                // We only scan the grid where we know ripples exist to save performance
                // But for simplicity on this scale, we scan the whole screen with a coarser step
                // Optimization: Only draw characters if they are near a ripple ring
                
                // Iterate over active ripples to draw them
                // NOTE: This approach is slightly different from the previous one. 
                // Instead of iterating pixels, we iterate ripples -> then iterate ring circumference.
                // This is much more efficient for "small" scattered ripples.

                ripples.forEach(r => {
                    const { radius, alpha } = r.getCurrentState();
                    
                    if (alpha <= 0.01) return;

                    // Draw characters along the circumference of the circle
                    // Circumference = 2 * pi * r
                    // We want a character every ~15px
                    const circumference = 2 * Math.PI * radius;
                    const charCount = Math.floor(circumference / (FONT_SIZE * 0.8));
                    
                    for (let i = 0; i < charCount; i++) {
                        const angle = (i / charCount) * Math.PI * 2;
                        const charX = r.x + Math.cos(angle) * radius;
                        const charY = r.y + Math.sin(angle) * radius;

                        // Check canvas bounds
                        if (charX < 0 || charX > w || charY < 0 || charY > h) continue;

                        // Double check collision (redundant but safe)
                        // If the ripple expands INTO the text area, don't draw that specific character
                        const rect = contentBlock.getBoundingClientRect();
                        if (charX > rect.left - 20 && charX < rect.right + 20 &&
                            charY > rect.top - 20 && charY < rect.bottom + 20) {
                            continue;
                        }

                        // Draw
                        const charIndex = Math.floor((charX + charY) % CHARS.length);
                        const isDark = body.classList.contains('dark-mode');
                        
                        ctx.fillStyle = isDark 
                            ? `rgba(255, 255, 255, ${alpha})` 
                            : `rgba(0, 0, 0, ${alpha})`;
                        
                        ctx.fillText(CHARS[charIndex], charX, charY);
                    }
                });
            }

            requestAnimationFrame(animate);
        }

        animate();

    </script>
</body>
</html>

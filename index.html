<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>michael cheng</title>
    <style>
        :root {
            /* LIGHT MODE */
            --bg: #ffffff;
            --headings: #000000;
            --text: #555555;
            --btn-active: #000000;
        }

        body.dark-mode {
            /* DARK MODE */
            --bg: #111111;
            --headings: #ffffff;
            --text: #a0a0a0;
            --btn-active: #ffffff;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background-color: var(--bg);
            color: var(--text);
            font-family: Menlo, Monaco, Consolas, "Courier New", monospace;
            font-size: 14px;
            line-height: 1.6;
            text-transform: lowercase;
            
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 2rem;
            
            transition: background-color 0.3s, color 0.3s;
            overflow-x: hidden;
            user-select: none; 
        }

        main {
            max-width: 520px;
            width: 100%;
            text-align: left;
            position: relative;
            z-index: 10; 
        }

        h1 {
            color: var(--headings);
            font-size: 14px;
            font-weight: normal;
            margin-bottom: 2rem;
        }

        p {
            margin-bottom: 2rem;
        }

        ul {
            list-style: none;
            margin-bottom: 2rem;
        }

        li {
            margin-bottom: 0.5rem;
        }

        a {
            color: inherit;
            text-decoration: underline;
            cursor: pointer;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--headings);
            text-decoration-style: double;
        }

        /* BUTTONS */
        .corner-btn {
            position: fixed;
            bottom: 2rem;
            background: none;
            border: none;
            color: var(--text);
            font-family: inherit;
            font-size: 14px;
            cursor: pointer;
            text-decoration: underline;
            padding: 0.5rem;
            opacity: 0.7;
            z-index: 20;
        }

        .corner-btn:hover {
            color: var(--headings);
            opacity: 1;
        }

        .corner-btn:active {
            color: var(--headings);
            text-decoration-style: double;
        }

        #theme-toggle { right: 2rem; }
        #ripple-trigger { left: 2rem; }

        canvas#ascii-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 1;
        }
    </style>
</head>
<body>

    <canvas id="ascii-overlay"></canvas>

    <main id="content-block">
        <h1>michael cheng</h1>

        <p>
            lorem ipsum dolor sit amet, consectetur adipiscing elit. sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
        </p>

        <ul>
            <li>
                <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#109;&#101;&#64;&#109;&#105;&#99;&#104;&#97;&#101;&#108;&#99;&#104;&#101;&#110;&#103;&#46;&#100;&#101;&#118;">email</a>
            </li>
            <li>
                <a href="https://github.com/michaelchengdev">github</a>
            </li>
            <li>
                <a href="https://www.linkedin.com/in/michaelchengdev/">linkedin</a>
            </li>
        </ul>

        <p>
            viverra ipsum nunc aliquet bibendum enim facilisis gravida neque convallis.
        </p>
    </main>

    <button id="ripple-trigger" class="corner-btn">effect</button>
    <button id="theme-toggle" class="corner-btn">dark</button>

    <script>
        const toggleButton = document.getElementById('theme-toggle');
        const body = document.body;

        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            body.classList.add('dark-mode');
            toggleButton.textContent = 'light';
        }

        toggleButton.addEventListener('click', () => {
            body.classList.toggle('dark-mode');
            toggleButton.textContent = body.classList.contains('dark-mode') ? 'light' : 'dark';
        });

        // --- ASCII FLUID ENGINE v6 (Ramp-Up Accelerator) ---
        const canvas = document.getElementById('ascii-overlay');
        const ctx = canvas.getContext('2d');
        const triggerBtn = document.getElementById('ripple-trigger');
        const contentBlock = document.getElementById('content-block');
        
        const DENSITY_TIERS = [
            ['@', '#', 'O', '0', '8', '&'], 
            ['o', '*', 'x', '%', 'z'],
            ['+', '=', '~', '-', '^'],
            ['.', ',', '\'', '`', '_']      
        ];
        
        const FONT_SIZE = 14; 
        
        let drops = [];
        let w, h;
        
        // ACCELERATOR VARIABLES
        let isHolding = false;
        let spawnRate = 0;          // Current "energy" (0 to 100)
        let maxSpawnRate = 15;      // Max energy cap
        let rampUpSpeed = 0.5;      // How fast it speeds up
        let rampDownSpeed = 0.2;    // How fast it slows down (tapers off)

        function resize() {
            w = canvas.width = window.innerWidth;
            h = canvas.height = window.innerHeight;
            ctx.font = `${FONT_SIZE}px Menlo, Monaco, Consolas, monospace`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
        }
        window.addEventListener('resize', resize);
        resize();

        class RealisticDrop {
            constructor() {
                const rect = contentBlock.getBoundingClientRect();
                const padding = 50; 
                const side = Math.random() > 0.5 ? 'left' : 'right';
                
                if (side === 'left') {
                    this.x = Math.random() * (rect.left - padding);
                } else {
                    this.x = (rect.right + padding) + Math.random() * (w - (rect.right + padding));
                }
                this.y = Math.random() * h;
                
                const r = Math.random();
                if (r < 0.60) {
                    this.type = 'small';
                } else if (r < 0.90) {
                    this.type = 'medium';
                } else {
                    this.type = 'large';
                }

                this.age = 0;
                this.isDead = false;
                this.friction = 0.96; 
                this.radius = 0;

                if (this.type === 'small') {
                    this.maxAge = 50 + Math.random() * 20;  
                    this.velocity = 1.5 + Math.random();    
                    this.waveLength = 8 + Math.random() * 4;
                    this.maxIntensity = 0.5;                
                } else if (this.type === 'medium') {
                    this.maxAge = 80 + Math.random() * 30;
                    this.velocity = 2.0 + Math.random();
                    this.waveLength = 14 + Math.random() * 5;
                    this.maxIntensity = 0.8;                
                } else { 
                    this.maxAge = 120 + Math.random() * 40; 
                    this.velocity = 2.8 + Math.random();    
                    this.waveLength = 22 + Math.random() * 8; 
                    this.maxIntensity = 1.0;                
                }
            }

            update() {
                this.age++;
                this.radius += this.velocity;
                if (this.velocity > 0.2) this.velocity *= this.friction;
                
                if (this.age > this.maxAge) this.isDead = true;
            }

            getRings() {
                const rings = [];
                let progress = this.age / this.maxAge;
                let baseIntensity = this.maxIntensity * (1 - progress);
                
                if (baseIntensity <= 0) return [];

                for (let i = 0; i < 3; i++) {
                    const offset = i * this.waveLength;
                    const r = this.radius - offset;
                    if (r <= 0) continue;

                    let ringIntensity = baseIntensity * (1 - (i * 0.3));
                    ringIntensity *= (60 / (r + 60)); 

                    if (ringIntensity > 0.05) {
                        rings.push({ r: r, intensity: ringIntensity });
                    }
                }
                return rings;
            }
        }

        // --- INTERACTION ---
        triggerBtn.addEventListener('mousedown', () => { isHolding = true; });
        triggerBtn.addEventListener('mouseup', () => { isHolding = false; });
        triggerBtn.addEventListener('mouseleave', () => { isHolding = false; });
        
        triggerBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isHolding = true; 
        });
        triggerBtn.addEventListener('touchend', () => { isHolding = false; });
        
        // Single click gives a small nudge to the spawn rate
        triggerBtn.addEventListener('click', () => {
            spawnRate += 2; // Jumpstart
        });

        // --- ANIMATION ---
        function animate() {
            ctx.clearRect(0, 0, w, h);
            
            // 1. RATE CONTROLLER
            if (isHolding) {
                // Accelerate
                if (spawnRate < maxSpawnRate) {
                    spawnRate += rampUpSpeed;
                }
            } else {
                // Decelerate (Coast to stop)
                if (spawnRate > 0) {
                    spawnRate -= rampDownSpeed;
                }
            }
            
            // Hard floor at 0
            if (spawnRate < 0) spawnRate = 0;

            // 2. SPAWNER
            // spawnRate is roughly "drops per frame probability" * 10
            // e.g. spawnRate 10 = high chance, 1 = low chance
            if (spawnRate > 0) {
                // Determine how many to spawn this frame
                // We use a random chance based on the current rate
                const chance = Math.random() * 10;
                
                if (chance < spawnRate) {
                    // Spawn 1 drop
                    drops.push(new RealisticDrop());
                    
                    // If rate is really high, maybe spawn a second one
                    if (spawnRate > 10 && Math.random() > 0.5) {
                         drops.push(new RealisticDrop());
                    }
                }
            }

            // 3. PHYSICS
            drops = drops.filter(d => !d.isDead);

            drops.forEach(drop => {
                drop.update();
                const rings = drop.getRings();

                rings.forEach(ring => {
                    let safeIntensity = Math.max(0, Math.min(1, ring.intensity));
                    let tierIndex = Math.floor((1 - safeIntensity) * DENSITY_TIERS.length);
                    tierIndex = Math.max(0, Math.min(DENSITY_TIERS.length - 1, tierIndex));
                    
                    const charSet = DENSITY_TIERS[tierIndex];

                    const alpha = safeIntensity < 0.3 ? safeIntensity * 3 : 1;
                    const circumference = 2 * Math.PI * ring.r;
                    
                    const densityMod = drop.type === 'small' ? 1.5 : 1.2;
                    const charCount = Math.floor(circumference / (FONT_SIZE * densityMod));
                    
                    for (let i = 0; i < charCount; i++) {
                        const angle = (i / charCount) * Math.PI * 2;
                        const charX = drop.x + Math.cos(angle) * ring.r;
                        const charY = drop.y + Math.sin(angle) * ring.r;

                        if (charX < 0 || charX > w || charY < 0 || charY > h) continue;

                        const rect = contentBlock.getBoundingClientRect();
                        if (charX > rect.left - 20 && charX < rect.right + 20 &&
                            charY > rect.top - 20 && charY < rect.bottom + 20) {
                            continue;
                        }
                        
                        const hash = Math.floor(charX + charY);
                        const selectedChar = charSet[hash % charSet.length];

                        const isDark = body.classList.contains('dark-mode');
                        ctx.fillStyle = isDark 
                            ? `rgba(255, 255, 255, ${alpha})` 
                            : `rgba(0, 0, 0, ${alpha})`;
                        
                        ctx.fillText(selectedChar, charX, charY);
                    }
                });
            });

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>

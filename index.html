<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>michael cheng</title>
    <meta name="description" content="Personal website of Michael Cheng.">

    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><style>text{fill:black}@media(prefers-color-scheme:dark){text{fill:white}}</style><text y=%22.9em%22 font-size=%2290%22 font-family=%22monospace%22>m</text></svg>">

    <style>
        :root {
            /* LIGHT MODE COLORS */
            --bg: #ffffff;
            --headings: #000000;
            --text: #555555;
            --btn-active: #000000;
        }

        body.dark-mode {
            /* DARK MODE COLORS */
            --bg: #111111;
            --headings: #ffffff;
            --text: #a0a0a0;
            --btn-active: #ffffff;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background-color: var(--bg);
            color: var(--text);
            /* Monospace Stack */
            font-family: Menlo, Monaco, Consolas, "Courier New", monospace;
            font-size: 14px;
            line-height: 1.6;
            text-transform: lowercase;
            
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 2rem;
            
            transition: background-color 0.3s, color 0.3s;
            overflow-x: hidden;
            
            /* ALLOW SELECTION of text */
            user-select: text; 
        }

        main {
            max-width: 520px;
            width: 100%;
            text-align: left;
            position: relative;
            /* Z-index 10 puts content above the snow but allows blending */
            z-index: 10; 
        }

        h1 {
            color: var(--headings);
            font-size: 14px;
            font-weight: normal;
            margin-bottom: 2rem;
        }

        p {
            margin-bottom: 2rem;
        }

        ul {
            list-style: none;
            margin-bottom: 2rem;
        }

        li {
            margin-bottom: 0.5rem;
        }

        a {
            color: inherit;
            text-decoration: underline;
            cursor: pointer;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--headings);
            text-decoration: underline; /* Standard underline on hover */
        }

        /* BUTTONS */
        .corner-btn {
            position: fixed;
            bottom: 2rem;
            background: none;
            border: none;
            color: var(--text);
            font-family: inherit;
            font-size: 14px;
            cursor: pointer;
            text-decoration: underline;
            padding: 0.5rem;
            opacity: 0.7;
            z-index: 20;
            user-select: none; /* Keep UI buttons unselectable */
        }

        .corner-btn:hover {
            color: var(--headings);
            opacity: 1;
        }

        .corner-btn:active {
            color: var(--headings);
        }

        #theme-toggle { right: 2rem; }
        #ripple-trigger { left: 2rem; }

        /* Hide Snow button on Mobile */
        @media (max-width: 768px) {
            #ripple-trigger {
                display: none;
            }
        }

        /* DOM SNOW CONTAINER */
        #ripple-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass through */
            z-index: 1;
            overflow: hidden;
        }

        /* The individual snow characters */
        .ripple-char {
            position: absolute;
            pointer-events: auto; /* Allow selecting the snow text */
            user-select: text;
            will-change: transform, opacity;
            white-space: pre; 
        }

    </style>
</head>
<body>

    <div id="ripple-container"></div>

    <main id="content-block">
        <h1>michael cheng</h1>

        <p>
            lorem ipsum dolor sit amet, consectetur adipiscing elit. sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
        </p>

        <ul>
            <li>
                <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#109;&#101;&#64;&#109;&#105;&#99;&#104;&#97;&#101;&#108;&#99;&#104;&#101;&#110;&#103;&#46;&#100;&#101;&#118;">email</a>
            </li>
            <li>
                <a href="https://github.com/michaelchengdev">github</a>
            </li>
            <li>
                <a href="https://www.linkedin.com/in/michaelchengdev/">linkedin</a>
            </li>
        </ul>

        <p>
            viverra ipsum nunc aliquet bibendum enim facilisis gravida neque convallis.
        </p>
    </main>

    <button id="ripple-trigger" class="corner-btn">snow</button>
    <button id="theme-toggle" class="corner-btn">dark</button>

    <script>
        // --- THEME LOGIC ---
        const toggleButton = document.getElementById('theme-toggle');
        const body = document.body;

        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            body.classList.add('dark-mode');
            toggleButton.textContent = 'light';
        }

        toggleButton.addEventListener('click', () => {
            body.classList.toggle('dark-mode');
            toggleButton.textContent = body.classList.contains('dark-mode') ? 'light' : 'dark';
        });

        // --- DOM-BASED SNOW ENGINE ---
        const container = document.getElementById('ripple-container');
        const triggerBtn = document.getElementById('ripple-trigger');
        const contentBlock = document.getElementById('content-block');
        
        // Snowflake characters
        const SNOWFLAKES = ['*'];
        
        // GRID SETTINGS
        const FONT_SIZE = 14; 
        const LINE_HEIGHT = 1.6;
        const CELL_HEIGHT = FONT_SIZE * LINE_HEIGHT; 
        const CELL_WIDTH = FONT_SIZE * 0.6; 
        
        let snowflakes = [];
        let w = window.innerWidth;
        let h = window.innerHeight;
        
        // --- OBJECT POOL (Optimization) ---
        const MAX_PARTICLES = 400; 
        const spanPool = [];
        
        // Initialize Pool of spans
        for (let i = 0; i < MAX_PARTICLES; i++) {
            const span = document.createElement('span');
            span.className = 'ripple-char';
            span.style.opacity = '0'; 
            container.appendChild(span);
            spanPool.push(span);
        }

        // CONTROL VARIABLES
        let isSnowing = false;
        let spawnRate = 0;          
        let maxSpawnRate = 1.5;      
        let rampUpSpeed = 0.05;      
        let rampDownSpeed = 0.02;    

        window.addEventListener('resize', () => {
            w = window.innerWidth;
            h = window.innerHeight;
        });

        class Snowflake {
            constructor() {
                this.x = Math.random() * w;
                this.y = -20;
                this.char = SNOWFLAKES[Math.floor(Math.random() * SNOWFLAKES.length)];
                
                // Varied falling speeds
                this.speed = 0.5 + Math.random() * 1.5;
                
                // Gentle horizontal drift
                this.drift = (Math.random() - 0.5) * 0.5;
                
                // Slight rotation effect
                this.wobble = Math.random() * Math.PI * 2;
                this.wobbleSpeed = (Math.random() - 0.5) * 0.02;
                
                // Size variation
                const sizeRand = Math.random();
                if (sizeRand < 0.5) {
                    this.size = 0.7;
                    this.opacity = 0.4 + Math.random() * 0.3;
                } else if (sizeRand < 0.85) {
                    this.size = 1.0;
                    this.opacity = 0.6 + Math.random() * 0.3;
                } else {
                    this.size = 1.3;
                    this.opacity = 0.8 + Math.random() * 0.2;
                }
                
                this.isDead = false;
            }

            update() {
                this.y += this.speed;
                this.wobble += this.wobbleSpeed;
                this.x += this.drift + Math.sin(this.wobble) * 0.3;
                
                // Remove if off screen
                if (this.y > h + 20 || this.x < -20 || this.x > w + 20) {
                    this.isDead = true;
                }
            }
        }

        // Interaction Handlers
        triggerBtn.addEventListener('mousedown', () => { isSnowing = true; });
        triggerBtn.addEventListener('mouseup', () => { isSnowing = false; });
        triggerBtn.addEventListener('mouseleave', () => { isSnowing = false; });
        triggerBtn.addEventListener('click', () => { spawnRate = Math.min(spawnRate + 0.8, maxSpawnRate); });

        // --- MAIN ANIMATION LOOP ---
        function animate() {
            // 1. Ramp Rate Logic
            if (isSnowing) {
                if (spawnRate < maxSpawnRate) spawnRate += rampUpSpeed;
            } else {
                if (spawnRate > 0) spawnRate -= rampDownSpeed;
            }
            if (spawnRate < 0) spawnRate = 0;

            // 2. Spawn Logic
            if (spawnRate > 0) {
                const spawnCount = Math.floor(spawnRate);
                const fractional = spawnRate - spawnCount;
                
                for (let i = 0; i < spawnCount; i++) {
                    snowflakes.push(new Snowflake());
                }
                
                if (Math.random() < fractional) {
                    snowflakes.push(new Snowflake());
                }
            }

            snowflakes = snowflakes.filter(s => !s.isDead);
            
            // 3. Render Phase
            let poolIndex = 0;
            const contentRect = contentBlock.getBoundingClientRect();
            
            snowflakes.forEach(flake => {
                flake.update();
                
                if (poolIndex >= MAX_PARTICLES) return;

                // Content collision check (snowflakes pass through content)
                const isOverContent = flake.x > contentRect.left - 20 && 
                                     flake.x < contentRect.right + 20 &&
                                     flake.y > contentRect.top - 20 && 
                                     flake.y < contentRect.bottom + 20;

                // SNAP TO GRID
                const col = Math.floor(flake.x / CELL_WIDTH);
                const row = Math.floor(flake.y / CELL_HEIGHT);
                const snappedX = col * CELL_WIDTH;
                const snappedY = row * CELL_HEIGHT + (CELL_HEIGHT - FONT_SIZE)/2;

                // Grab span from pool
                const span = spanPool[poolIndex];
                poolIndex++;

                // Apply styles
                span.style.transform = `translate3d(${snappedX}px, ${snappedY}px, 0) scale(${flake.size})`;
                span.textContent = flake.char;
                span.style.opacity = isOverContent ? flake.opacity * 0.3 : flake.opacity;
                
                const isDark = body.classList.contains('dark-mode');
                span.style.color = isDark ? `rgba(255, 255, 255, 1)` : `rgba(0, 0, 0, 1)`;
            });

            // 4. Cleanup Unused Spans
            for (let i = poolIndex; i < MAX_PARTICLES; i++) {
                spanPool[i].style.opacity = '0';
            }

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>

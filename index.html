<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>michael cheng</title>
    <style>
        :root {
            /* LIGHT MODE */
            --bg: #ffffff;
            --headings: #000000;
            --text: #555555;
            --btn-active: #000000;
        }

        body.dark-mode {
            /* DARK MODE */
            --bg: #111111;
            --headings: #ffffff;
            --text: #a0a0a0;
            --btn-active: #ffffff;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background-color: var(--bg);
            color: var(--text);
            /* Monospace is critical for the grid alignment */
            font-family: Menlo, Monaco, Consolas, "Courier New", monospace;
            font-size: 14px;
            line-height: 1.6;
            text-transform: lowercase;
            
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 2rem;
            
            transition: background-color 0.3s, color 0.3s;
            overflow-x: hidden;
        }

        main {
            max-width: 520px;
            width: 100%;
            text-align: left;
            position: relative;
            z-index: 10; 
        }

        h1 {
            color: var(--headings);
            font-size: 14px;
            font-weight: normal;
            margin-bottom: 2rem;
        }

        p {
            margin-bottom: 2rem;
        }

        ul {
            list-style: none;
            margin-bottom: 2rem;
        }

        li {
            margin-bottom: 0.5rem;
        }

        a {
            color: inherit;
            text-decoration: underline;
            cursor: pointer;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--headings);
            text-decoration: underline; 
        }

        /* BUTTONS */
        .corner-btn {
            position: fixed;
            bottom: 2rem;
            background: none;
            border: none;
            color: var(--text);
            font-family: inherit;
            font-size: 14px;
            cursor: pointer;
            text-decoration: underline;
            padding: 0.5rem;
            opacity: 0.7;
            z-index: 20;
            user-select: none;
        }

        .corner-btn:hover {
            color: var(--headings);
            opacity: 1;
        }

        #theme-toggle { right: 2rem; }
        #ripple-trigger { left: 2rem; }

        @media (max-width: 768px) {
            #ripple-trigger { display: none; }
        }

        /* THE GRID CONTAINER */
        #text-grid-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass through */
            z-index: 1;
            overflow: hidden;
            
            /* Use Flex/Grid to organize the spans? No, absolute is faster for layout here */
        }

        /* The static grid cells */
        .grid-char {
            position: absolute;
            pointer-events: auto; /* ENABLE SELECTION */
            user-select: text;
            /* Monospace metrics */
            width: 8.4px;  /* Approx width of 14px mono char */
            height: 22.4px; /* 14px * 1.6 line-height */
            text-align: center;
            opacity: 0; /* Hidden by default */
            /* Optimization */
            will-change: opacity, content; 
        }

    </style>
</head>
<body>

    <div id="text-grid-container"></div>

    <main id="content-block">
        <h1>michael cheng</h1>

        <p>
            lorem ipsum dolor sit amet, consectetur adipiscing elit. sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
        </p>

        <ul>
            <li>
                <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#109;&#101;&#64;&#109;&#105;&#99;&#104;&#97;&#101;&#108;&#99;&#104;&#101;&#110;&#103;&#46;&#100;&#101;&#118;">email</a>
            </li>
            <li>
                <a href="https://github.com/michaelchengdev">github</a>
            </li>
            <li>
                <a href="https://www.linkedin.com/in/michaelchengdev/">linkedin</a>
            </li>
        </ul>

        <p>
            viverra ipsum nunc aliquet bibendum enim facilisis gravida neque convallis.
        </p>
    </main>

    <button id="ripple-trigger" class="corner-btn">rain</button>
    <button id="theme-toggle" class="corner-btn">dark</button>

    <script>
        const toggleButton = document.getElementById('theme-toggle');
        const body = document.body;

        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            body.classList.add('dark-mode');
            toggleButton.textContent = 'light';
        }

        toggleButton.addEventListener('click', () => {
            body.classList.toggle('dark-mode');
            toggleButton.textContent = body.classList.contains('dark-mode') ? 'light' : 'dark';
        });

        // --- STATIC GRID ENGINE ---
        const container = document.getElementById('text-grid-container');
        const triggerBtn = document.getElementById('ripple-trigger');
        const contentBlock = document.getElementById('content-block');
        
        const DENSITY_TIERS = [
            ['@', '#', 'O', '0', '8', '&'], 
            ['o', '*', 'x', '%', 'z'],
            ['+', '=', '~', '-', '^'],
            ['.', ',', '\'', '`', '_']      
        ];
        
        // METRICS
        // NOTE: These must match CSS exactly for alignment
        const FONT_SIZE = 14; 
        const LINE_HEIGHT = 1.6;
        const CELL_H = FONT_SIZE * LINE_HEIGHT; // 22.4
        const CELL_W = FONT_SIZE * 0.6; // ~8.4px (Standard monospace ratio)
        
        let drops = [];
        // The Grid: 2D array of DOM Nodes
        let grid = []; 
        let cols = 0;
        let rows = 0;
        
        // Optimization: Track which cells are currently visible to clean them up efficiently
        let activeCells = new Set();

        function initGrid() {
            // Clear existing
            container.innerHTML = '';
            grid = [];
            activeCells.clear();

            const w = window.innerWidth;
            const h = window.innerHeight;
            const contentRect = contentBlock.getBoundingClientRect();
            
            cols = Math.ceil(w / CELL_W);
            rows = Math.ceil(h / CELL_H);
            
            // Generate spans
            // We optimize by NOT creating spans underneath the main content text
            // to keep the DOM lighter (saves ~30% of nodes)
            
            for (let y = 0; y < rows; y++) {
                const rowArr = [];
                const yPos = y * CELL_H;
                
                // Vertical collision with content block?
                const inContentY = (yPos > contentRect.top - 20) && (yPos < contentRect.bottom + 20);

                for (let x = 0; x < cols; x++) {
                    const xPos = x * CELL_W;
                    
                    // Horizontal collision?
                    const inContentX = (xPos > contentRect.left - 20) && (xPos < contentRect.right + 20);

                    // If inside content block, push null (don't render rain on top of text)
                    if (inContentY && inContentX) {
                        rowArr.push(null);
                        continue;
                    }

                    const span = document.createElement('span');
                    span.className = 'grid-char';
                    span.style.left = `${xPos}px`;
                    span.style.top = `${yPos + (CELL_H - FONT_SIZE)/2}px`; // Vertical align correction
                    
                    // We attach custom data properties to the DOM node for state tracking
                    span.dataset.active = "false"; 
                    
                    container.appendChild(span);
                    rowArr.push(span);
                }
                grid.push(rowArr);
            }
        }
        
        // Initialize and handle resize
        initGrid();
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(initGrid, 200);
        });

        // CONTROL
        let isHolding = false;
        let spawnRate = 0;          
        let maxSpawnRate = 1.5;      
        let rampUpSpeed = 0.05;      
        let rampDownSpeed = 0.02;    

        class RealisticDrop {
            constructor() {
                const rect = contentBlock.getBoundingClientRect();
                const padding = 50; 
                const w = window.innerWidth;
                const h = window.innerHeight;
                
                const side = Math.random() > 0.5 ? 'left' : 'right';
                if (side === 'left') {
                    this.x = Math.random() * (rect.left - padding);
                } else {
                    this.x = (rect.right + padding) + Math.random() * (w - (rect.right + padding));
                }
                this.y = Math.random() * h;
                
                const r = Math.random();
                if (r < 0.60) { this.type = 'small'; } 
                else if (r < 0.90) { this.type = 'medium'; } 
                else { this.type = 'large'; }

                this.age = 0;
                this.isDead = false;
                this.friction = 0.96; 
                this.radius = 0;

                if (this.type === 'small') {
                    this.maxAge = 50 + Math.random() * 20;  
                    this.velocity = 1.5 + Math.random();    
                    this.waveLength = 8 + Math.random() * 4;
                    this.maxIntensity = 0.5;                
                } else if (this.type === 'medium') {
                    this.maxAge = 80 + Math.random() * 30;
                    this.velocity = 2.0 + Math.random();
                    this.waveLength = 14 + Math.random() * 5;
                    this.maxIntensity = 0.8;                
                } else { 
                    this.maxAge = 120 + Math.random() * 40; 
                    this.velocity = 2.8 + Math.random();    
                    this.waveLength = 22 + Math.random() * 8; 
                    this.maxIntensity = 1.0;                
                }
            }

            update() {
                this.age++;
                this.radius += this.velocity;
                if (this.velocity > 0.2) this.velocity *= this.friction;
                if (this.age > this.maxAge) this.isDead = true;
            }

            getRings() {
                const rings = [];
                let progress = this.age / this.maxAge;
                let baseIntensity = this.maxIntensity * (1 - progress);
                if (baseIntensity <= 0) return [];

                for (let i = 0; i < 3; i++) {
                    const offset = i * this.waveLength;
                    const r = this.radius - offset;
                    if (r <= 0) continue;

                    let ringIntensity = baseIntensity * (1 - (i * 0.3));
                    ringIntensity *= (60 / (r + 60)); 

                    if (ringIntensity > 0.05) {
                        rings.push({ r: r, intensity: ringIntensity });
                    }
                }
                return rings;
            }
        }

        triggerBtn.addEventListener('mousedown', () => { isHolding = true; });
        triggerBtn.addEventListener('mouseup', () => { isHolding = false; });
        triggerBtn.addEventListener('mouseleave', () => { isHolding = false; });
        triggerBtn.addEventListener('click', () => { spawnRate = Math.min(spawnRate + 1, maxSpawnRate); });

        // --- ANIMATION ---
        function animate() {
            // 1. Logic
            if (isHolding) {
                if (spawnRate < maxSpawnRate) spawnRate += rampUpSpeed;
            } else {
                if (spawnRate > 0) spawnRate -= rampDownSpeed;
            }
            if (spawnRate < 0) spawnRate = 0;

            if (spawnRate > 0) {
                const chance = Math.random() * 10;
                if (chance < spawnRate) drops.push(new RealisticDrop());
            }

            drops = drops.filter(d => !d.isDead);

            // 2. Render - "Dirty Check" Strategy
            // Instead of looping all 5000+ grid cells, we calculate the bounds of each drop
            // and only update cells in that area.

            const nextActiveCells = new Set();
            const w = window.innerWidth;
            const h = window.innerHeight;

            drops.forEach(drop => {
                drop.update();
                const rings = drop.getRings();

                rings.forEach(ring => {
                    let safeIntensity = Math.max(0, Math.min(1, ring.intensity));
                    let tierIndex = Math.floor((1 - safeIntensity) * DENSITY_TIERS.length);
                    tierIndex = Math.max(0, Math.min(DENSITY_TIERS.length - 1, tierIndex));
                    
                    const charSet = DENSITY_TIERS[tierIndex];
                    const alpha = safeIntensity < 0.3 ? safeIntensity * 3 : 1;

                    // Calculate bounding box in GRID COORDINATES
                    // Ring radius + margin
                    const r = ring.r;
                    const minCol = Math.max(0, Math.floor((drop.x - r) / CELL_W));
                    const maxCol = Math.min(cols - 1, Math.ceil((drop.x + r) / CELL_W));
                    const minRow = Math.max(0, Math.floor((drop.y - r) / CELL_H));
                    const maxRow = Math.min(rows - 1, Math.ceil((drop.y + r) / CELL_H));

                    // Iterate only the cells in this box
                    for (let rIdx = minRow; rIdx <= maxRow; rIdx++) {
                        for (let cIdx = minCol; cIdx <= maxCol; cIdx++) {
                            
                            const cell = grid[rIdx][cIdx];
                            if (!cell) continue; // Inside content block

                            // Exact distance check
                            const cellX = cIdx * CELL_W;
                            const cellY = rIdx * CELL_H;
                            const dx = cellX - drop.x;
                            const dy = cellY - drop.y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            
                            // Check if this cell is actually on the ring line
                            // We allow a "thickness" of about 1 cell width
                            if (Math.abs(dist - ring.r) < CELL_W) {
                                
                                const hash = rIdx + cIdx;
                                const char = charSet[hash % charSet.length];
                                
                                // Update DOM
                                cell.textContent = char;
                                cell.style.opacity = alpha;
                                
                                // Color logic
                                const isDark = body.classList.contains('dark-mode');
                                cell.style.color = isDark ? '#ffffff' : '#000000';

                                nextActiveCells.add(cell);
                            }
                        }
                    }
                });
            });

            // 3. Cleanup
            // Any cell that was active last frame but is NOT active this frame needs to be hidden
            activeCells.forEach(cell => {
                if (!nextActiveCells.has(cell)) {
                    cell.style.opacity = '0';
                }
            });

            activeCells = nextActiveCells;

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>

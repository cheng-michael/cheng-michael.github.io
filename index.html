<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>michael cheng</title>
    <meta name="description" content="Personal website of Michael Cheng.">

    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><style>text{fill:black}@media(prefers-color-scheme:dark){text{fill:white}}</style><text y=%22.9em%22 font-size=%2290%22 font-family=%22monospace%22>m</text></svg>">

    <style>
        :root {
            /* LIGHT MODE COLORS */
            --bg: #ffffff;
            --headings: #000000;
            --text: #555555;
            --btn-active: #000000;
        }

        body.dark-mode {
            /* DARK MODE COLORS */
            --bg: #111111;
            --headings: #ffffff;
            --text: #a0a0a0;
            --btn-active: #ffffff;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background-color: var(--bg);
            color: var(--text);
            /* Monospace Stack */
            font-family: Menlo, Monaco, Consolas, "Courier New", monospace;
            font-size: 14px;
            line-height: 1.6;
            text-transform: lowercase;
            
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 2rem;
            
            transition: background-color 0.3s, color 0.3s;
            overflow-x: hidden;
            
            /* ALLOW SELECTION of text */
            user-select: text; 
        }

        main {
            max-width: 520px;
            width: 100%;
            text-align: left;
            position: relative;
            /* Z-index 10 puts content above the snow but allows blending */
            z-index: 10; 
        }

        h1 {
            color: var(--headings);
            font-size: 14px;
            font-weight: normal;
            margin-bottom: 2rem;
        }

        p {
            margin-bottom: 2rem;
        }

        ul {
            list-style: none;
            margin-bottom: 2rem;
        }

        li {
            margin-bottom: 0.5rem;
        }

        a {
            color: inherit;
            text-decoration: underline;
            cursor: pointer;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--headings);
            text-decoration: underline; /* Standard underline on hover */
        }

        /* BUTTONS */
        .corner-btn {
            position: fixed;
            bottom: 2rem;
            background: none;
            border: none;
            color: var(--text);
            font-family: inherit;
            font-size: 14px;
            cursor: pointer;
            text-decoration: underline;
            padding: 0.5rem;
            opacity: 0.7;
            z-index: 20;
            user-select: none; /* Keep UI buttons unselectable */
        }

        .corner-btn:hover {
            color: var(--headings);
            opacity: 1;
        }

        .corner-btn:active {
            color: var(--headings);
        }

        #theme-toggle { right: 2rem; }
        #ripple-trigger { left: 2rem; }

        /* Hide Snow button on Mobile */
        @media (max-width: 768px) {
            #ripple-trigger {
                display: none;
            }
        }

        /* DOM SNOW CONTAINER */
        #ripple-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass through */
            z-index: 1;
            overflow: hidden;
            font-family: Menlo, Monaco, Consolas, "Courier New", monospace;
            font-size: 14px;
            line-height: 1.6;
            color: var(--text);
        }

        /* The individual snow characters */
        .ripple-char {
            position: absolute;
            pointer-events: auto;
            user-select: text;
        }

    </style>
</head>
<body>

    <div id="ripple-container"></div>

    <main id="content-block">
        <h1>michael cheng</h1>

        <p>
            lorem ipsum dolor sit amet, consectetur adipiscing elit. sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
        </p>

        <ul>
            <li>
                <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#109;&#101;&#64;&#109;&#105;&#99;&#104;&#97;&#101;&#108;&#99;&#104;&#101;&#110;&#103;&#46;&#100;&#101;&#118;">email</a>
            </li>
            <li>
                <a href="https://github.com/michaelchengdev">github</a>
            </li>
            <li>
                <a href="https://www.linkedin.com/in/michaelchengdev/">linkedin</a>
            </li>
        </ul>

        <p>
            viverra ipsum nunc aliquet bibendum enim facilisis gravida neque convallis.
        </p>
    </main>

    <button id="ripple-trigger" class="corner-btn">snow</button>
    <button id="theme-toggle" class="corner-btn">dark</button>

    <script>
        // --- THEME LOGIC ---
        const toggleButton = document.getElementById('theme-toggle');
        const body = document.body;

        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            body.classList.add('dark-mode');
            toggleButton.textContent = 'light';
        }

        toggleButton.addEventListener('click', () => {
            body.classList.toggle('dark-mode');
            toggleButton.textContent = body.classList.contains('dark-mode') ? 'light' : 'dark';
        });

        // --- DOM-BASED SNOW ENGINE ---
        const container = document.getElementById('ripple-container');
        const triggerBtn = document.getElementById('ripple-trigger');
        const contentBlock = document.getElementById('content-block');
        
        // Snowflake characters
        const SNOWFLAKES = ['*'];
        
        // GRID SETTINGS - must match actual monospace character dimensions
        const FONT_SIZE = 14; 
        const LINE_HEIGHT = 1.6;
        const CELL_HEIGHT = FONT_SIZE * LINE_HEIGHT; // 22.4px
        const CELL_WIDTH = FONT_SIZE * 0.6; // 8.4px for monospace
        
        let snowflakes = [];
        let w = window.innerWidth;
        let h = window.innerHeight;
        
        // --- OBJECT POOL (Optimization) ---
        const MAX_PARTICLES = 50; 
        const spanPool = [];
        
        // Initialize Pool of spans
        for (let i = 0; i < MAX_PARTICLES; i++) {
            const span = document.createElement('span');
            span.className = 'ripple-char';
            span.style.opacity = '0'; 
            container.appendChild(span);
            spanPool.push(span);
        }

        // CONTROL VARIABLES
        let isSnowing = false;
        let spawnRate = 0;          
        let maxSpawnRate = 0.2;      
        let rampUpSpeed = 0.01;      
        let rampDownSpeed = 0.005;    

        window.addEventListener('resize', () => {
            w = window.innerWidth;
            h = window.innerHeight;
        });

        class Snowflake {
            constructor() {
                this.x = Math.random() * w;
                this.y = -(CELL_HEIGHT * 2 + Math.random() * CELL_HEIGHT * 3); // Start between -2 and -5 cells above screen
                this.char = SNOWFLAKES[Math.floor(Math.random() * SNOWFLAKES.length)];
                
                // Varied falling speeds
                this.speed = 0.5 + Math.random() * 1.5;
                
                // Gentle horizontal drift
                this.drift = (Math.random() - 0.5) * 0.5;
                
                // Slight rotation effect
                this.wobble = Math.random() * Math.PI * 2;
                this.wobbleSpeed = (Math.random() - 0.5) * 0.02;
                
                // Single opacity for all
                this.opacity = 1.0;
                
                this.isDead = false;
                this.despawnTime = null; // When to despawn (null = not despawning)
                
                console.log('Snowflake spawned at y:', this.y, 'CELL_HEIGHT:', CELL_HEIGHT);
            }

            update() {
                // Handle despawn timer
                if (this.despawnTime !== null) {
                    if (Date.now() >= this.despawnTime) {
                        this.isDead = true;
                        return;
                    }
                }
                
                this.y += this.speed;
                this.wobble += this.wobbleSpeed;
                this.x += this.drift + Math.sin(this.wobble) * 0.3;
                
                // Remove if off screen
                if (this.y > h + 20 || this.x < -20 || this.x > w + 20) {
                    this.isDead = true;
                }
            }
            
            startDespawn() {
                if (this.despawnTime === null) {
                    // Random time between 0 and 2000ms from now
                    const randomDelay = Math.random() * 2000;
                    this.despawnTime = Date.now() + randomDelay;
                }
            }
            
            getGridKey(col, row) {
                return `${col},${row}`;
            }
        }

        // Interaction Handlers
        let releaseTimeout = null;
        
        triggerBtn.addEventListener('mousedown', () => { 
            isSnowing = true;
            // Clear any pending release timeout
            if (releaseTimeout) {
                clearTimeout(releaseTimeout);
                releaseTimeout = null;
            }
        });
        
        const handleRelease = () => {
            isSnowing = false;
            // Immediately start despawn for ALL existing snowflakes
            if (snowflakes.length > 0) {
                snowflakes.forEach(flake => {
                    if (!flake.isDead) {
                        flake.startDespawn();
                    }
                });
            }
        };
        
        triggerBtn.addEventListener('mouseup', handleRelease);
        triggerBtn.addEventListener('mouseleave', () => {
            if (isSnowing) {
                handleRelease();
            }
        });
        triggerBtn.addEventListener('click', () => { 
            spawnRate = Math.min(spawnRate + 0.15, maxSpawnRate);
        });

        // --- MAIN ANIMATION LOOP ---
        function animate() {
            // 1. Ramp Rate Logic
            if (isSnowing) {
                if (spawnRate < maxSpawnRate) spawnRate += rampUpSpeed;
            } else {
                if (spawnRate > 0) spawnRate -= rampDownSpeed;
            }
            if (spawnRate < 0) spawnRate = 0;

            // 2. Spawn Logic
            if (spawnRate > 0) {
                const spawnCount = Math.floor(spawnRate);
                const fractional = spawnRate - spawnCount;
                
                for (let i = 0; i < spawnCount; i++) {
                    const newFlake = new Snowflake();
                    snowflakes.push(newFlake);
                    // If we're not actively snowing, immediately mark for despawn
                    if (!isSnowing) {
                        newFlake.startDespawn();
                    }
                }
                
                if (Math.random() < fractional) {
                    const newFlake = new Snowflake();
                    snowflakes.push(newFlake);
                    // If we're not actively snowing, immediately mark for despawn
                    if (!isSnowing) {
                        newFlake.startDespawn();
                    }
                }
            }

            // Filter out dead snowflakes BEFORE rendering
            snowflakes = snowflakes.filter(s => !s.isDead);
            
            // 3. Render Phase
            let poolIndex = 0;
            const contentRect = contentBlock.getBoundingClientRect();
            
            snowflakes.forEach(flake => {
                flake.update();
                
                if (flake.isDead) return;
                if (poolIndex >= MAX_PARTICLES) return;

                // SNAP TO GRID
                const col = Math.floor(flake.x / CELL_WIDTH);
                const row = Math.floor(flake.y / CELL_HEIGHT);
                
                // Skip if way off screen bottom
                if (flake.y > h + 20) return;
                
                const snappedX = col * CELL_WIDTH;
                const snappedY = row * CELL_HEIGHT;
                
                // Debug: Log first few renders
                if (poolIndex < 3) {
                    console.log('Rendering flake:', {realY: flake.y, snappedY, row, visible: snappedY >= -100});
                }

                // Content collision check (snowflakes pass through content)
                const isOverContent = flake.x > contentRect.left - 20 && 
                                     flake.x < contentRect.right + 20 &&
                                     flake.y > contentRect.top - 20 && 
                                     flake.y < contentRect.bottom + 20;

                // Grab span from pool
                const span = spanPool[poolIndex];
                poolIndex++;

                // Apply position using top/left instead of transform
                span.style.top = snappedY + 'px';
                span.style.left = snappedX + 'px';
                span.textContent = flake.char;
                span.style.opacity = isOverContent ? flake.opacity * 0.3 : flake.opacity;
            });

            // 4. Cleanup Unused Spans
            for (let i = poolIndex; i < spanPool.length; i++) {
                spanPool[i].style.opacity = '0';
            }

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>

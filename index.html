<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>michael cheng</title>
    <style>
        :root {
            /* LIGHT MODE */
            --bg: #ffffff;
            --headings: #000000;
            --text: #555555;
            --btn-active: #000000;
        }

        body.dark-mode {
            /* DARK MODE */
            --bg: #111111;
            --headings: #ffffff;
            --text: #a0a0a0;
            --btn-active: #ffffff;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background-color: var(--bg);
            color: var(--text);
            /* Monospace Stack */
            font-family: Menlo, Monaco, Consolas, "Courier New", monospace;
            font-size: 14px;
            line-height: 1.6; /* Important: Matches the grid logic */
            text-transform: lowercase;
            
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 2rem;
            
            transition: background-color 0.3s, color 0.3s;
            overflow-x: hidden;
            user-select: none; 
        }

        main {
            max-width: 520px;
            width: 100%;
            text-align: left;
            position: relative;
            z-index: 10; 
        }

        h1 {
            color: var(--headings);
            font-size: 14px;
            font-weight: normal;
            margin-bottom: 2rem;
        }

        p {
            margin-bottom: 2rem;
        }

        ul {
            list-style: none;
            margin-bottom: 2rem;
        }

        li {
            margin-bottom: 0.5rem;
        }

        a {
            color: inherit;
            text-decoration: underline;
            cursor: pointer;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--headings);
            text-decoration: underline; 
        }

        /* BUTTONS */
        .corner-btn {
            position: fixed;
            bottom: 2rem;
            background: none;
            border: none;
            color: var(--text);
            font-family: inherit;
            font-size: 14px;
            cursor: pointer;
            text-decoration: underline;
            padding: 0.5rem;
            opacity: 0.7;
            z-index: 20;
        }

        .corner-btn:hover {
            color: var(--headings);
            opacity: 1;
        }

        .corner-btn:active {
            color: var(--headings);
        }

        #theme-toggle { right: 2rem; }
        #ripple-trigger { left: 2rem; }

        @media (max-width: 768px) {
            #ripple-trigger {
                display: none;
            }
        }

        canvas#ascii-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 1;
        }
    </style>
</head>
<body>

    <canvas id="ascii-overlay"></canvas>

    <main id="content-block">
        <h1>michael cheng</h1>

        <p>
            lorem ipsum dolor sit amet, consectetur adipiscing elit. sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
        </p>

        <ul>
            <li>
                <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#109;&#101;&#64;&#109;&#105;&#99;&#104;&#97;&#101;&#108;&#99;&#104;&#101;&#110;&#103;&#46;&#100;&#101;&#118;">email</a>
            </li>
            <li>
                <a href="https://github.com/michaelchengdev">github</a>
            </li>
            <li>
                <a href="https://www.linkedin.com/in/michaelchengdev/">linkedin</a>
            </li>
        </ul>

        <p>
            viverra ipsum nunc aliquet bibendum enim facilisis gravida neque convallis.
        </p>
    </main>

    <button id="ripple-trigger" class="corner-btn">rain</button>
    <button id="theme-toggle" class="corner-btn">dark</button>

    <script>
        const toggleButton = document.getElementById('theme-toggle');
        const body = document.body;

        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            body.classList.add('dark-mode');
            toggleButton.textContent = 'light';
        }

        toggleButton.addEventListener('click', () => {
            body.classList.toggle('dark-mode');
            toggleButton.textContent = body.classList.contains('dark-mode') ? 'light' : 'dark';
        });

        // --- ASCII GRID ENGINE v1 (Crisp Text) ---
        const canvas = document.getElementById('ascii-overlay');
        const ctx = canvas.getContext('2d');
        const triggerBtn = document.getElementById('ripple-trigger');
        const contentBlock = document.getElementById('content-block');
        
        const DENSITY_TIERS = [
            ['@', '#', 'O', '0', '8', '&'], 
            ['o', '*', 'x', '%', 'z'],
            ['+', '=', '~', '-', '^'],
            ['.', ',', '\'', '`', '_']      
        ];
        
        // GRID CONFIGURATION
        const FONT_SIZE = 14; 
        const LINE_HEIGHT = 1.6;
        // Calculated cell sizes to match CSS
        const CELL_HEIGHT = FONT_SIZE * LINE_HEIGHT; // 14 * 1.6 = 22.4px
        const CELL_WIDTH = FONT_SIZE * 0.6; // Approx width of monospaced char
        
        let drops = [];
        let w, h;
        
        let isHolding = false;
        let spawnRate = 0;          
        let maxSpawnRate = 1.5;      
        let rampUpSpeed = 0.05;      
        let rampDownSpeed = 0.02;    

        function resize() {
            // Snap canvas size to nearest grid multiple to keep alignment perfect
            const rawW = window.innerWidth;
            const rawH = window.innerHeight;
            w = canvas.width = rawW;
            h = canvas.height = rawH;
            
            ctx.font = `${FONT_SIZE}px Menlo, Monaco, Consolas, monospace`;
            ctx.textBaseline = 'top'; // Draw from top-left of cell
        }
        window.addEventListener('resize', resize);
        resize();

        class RealisticDrop {
            constructor() {
                const rect = contentBlock.getBoundingClientRect();
                const padding = 50; 
                const side = Math.random() > 0.5 ? 'left' : 'right';
                
                if (side === 'left') {
                    this.x = Math.random() * (rect.left - padding);
                } else {
                    this.x = (rect.right + padding) + Math.random() * (w - (rect.right + padding));
                }
                this.y = Math.random() * h;
                
                const r = Math.random();
                if (r < 0.60) {
                    this.type = 'small';
                } else if (r < 0.90) {
                    this.type = 'medium';
                } else {
                    this.type = 'large';
                }

                this.age = 0;
                this.isDead = false;
                this.friction = 0.96; 
                this.radius = 0;

                if (this.type === 'small') {
                    this.maxAge = 50 + Math.random() * 20;  
                    this.velocity = 1.5 + Math.random();    
                    this.waveLength = 8 + Math.random() * 4;
                    this.maxIntensity = 0.5;                
                } else if (this.type === 'medium') {
                    this.maxAge = 80 + Math.random() * 30;
                    this.velocity = 2.0 + Math.random();
                    this.waveLength = 14 + Math.random() * 5;
                    this.maxIntensity = 0.8;                
                } else { 
                    this.maxAge = 120 + Math.random() * 40; 
                    this.velocity = 2.8 + Math.random();    
                    this.waveLength = 22 + Math.random() * 8; 
                    this.maxIntensity = 1.0;                
                }
            }

            update() {
                this.age++;
                this.radius += this.velocity;
                if (this.velocity > 0.2) this.velocity *= this.friction;
                if (this.age > this.maxAge) this.isDead = true;
            }

            getRings() {
                const rings = [];
                let progress = this.age / this.maxAge;
                let baseIntensity = this.maxIntensity * (1 - progress);
                if (baseIntensity <= 0) return [];

                for (let i = 0; i < 3; i++) {
                    const offset = i * this.waveLength;
                    const r = this.radius - offset;
                    if (r <= 0) continue;

                    let ringIntensity = baseIntensity * (1 - (i * 0.3));
                    ringIntensity *= (60 / (r + 60)); 

                    if (ringIntensity > 0.05) {
                        rings.push({ r: r, intensity: ringIntensity });
                    }
                }
                return rings;
            }
        }

        // --- INTERACTION ---
        triggerBtn.addEventListener('mousedown', () => { isHolding = true; });
        triggerBtn.addEventListener('mouseup', () => { isHolding = false; });
        triggerBtn.addEventListener('mouseleave', () => { isHolding = false; });
        triggerBtn.addEventListener('click', () => { spawnRate = Math.min(spawnRate + 1, maxSpawnRate); });

        // --- ANIMATION ---
        function animate() {
            ctx.clearRect(0, 0, w, h);
            
            // 1. RATE CONTROLLER
            if (isHolding) {
                if (spawnRate < maxSpawnRate) spawnRate += rampUpSpeed;
            } else {
                if (spawnRate > 0) spawnRate -= rampDownSpeed;
            }
            if (spawnRate < 0) spawnRate = 0;

            // 2. SPAWNER
            if (spawnRate > 0) {
                const chance = Math.random() * 10;
                if (chance < spawnRate) drops.push(new RealisticDrop());
            }

            // 3. PHYSICS & RENDER
            drops = drops.filter(d => !d.isDead);

            // To render cleanly, we need to map physics (circles) to the grid (cells).
            // Optimization: Only check cells near the rings.
            
            drops.forEach(drop => {
                drop.update();
                const rings = drop.getRings();

                rings.forEach(ring => {
                    let safeIntensity = Math.max(0, Math.min(1, ring.intensity));
                    let tierIndex = Math.floor((1 - safeIntensity) * DENSITY_TIERS.length);
                    tierIndex = Math.max(0, Math.min(DENSITY_TIERS.length - 1, tierIndex));
                    
                    const charSet = DENSITY_TIERS[tierIndex];
                    const alpha = safeIntensity < 0.3 ? safeIntensity * 3 : 1;

                    // GRID RENDERING LOGIC
                    // We iterate along the circumference, but we snap the results to the grid.
                    // We step by an angle that roughly corresponds to 1 cell width to avoid holes.
                    const circumference = 2 * Math.PI * ring.r;
                    const steps = Math.floor(circumference / CELL_WIDTH);
                    
                    for (let i = 0; i < steps; i++) {
                        const angle = (i / steps) * Math.PI * 2;
                        
                        // Raw float coordinates
                        const rawX = drop.x + Math.cos(angle) * ring.r;
                        const rawY = drop.y + Math.sin(angle) * ring.r;

                        // Check bounds before snapping
                        if (rawX < 0 || rawX > w || rawY < 0 || rawY > h) continue;

                        const rect = contentBlock.getBoundingClientRect();
                        if (rawX > rect.left - 20 && rawX < rect.right + 20 &&
                            rawY > rect.top - 20 && rawY < rect.bottom + 20) {
                            continue;
                        }

                        // SNAP TO GRID
                        // Calculate column and row index
                        const col = Math.floor(rawX / CELL_WIDTH);
                        const row = Math.floor(rawY / CELL_HEIGHT);

                        // Convert back to pixel coordinates for drawing
                        const snappedX = col * CELL_WIDTH;
                        const snappedY = row * CELL_HEIGHT + (CELL_HEIGHT - FONT_SIZE)/2; // Vertical center align

                        // Stable random char
                        const hash = col + row; 
                        const selectedChar = charSet[hash % charSet.length];

                        const isDark = body.classList.contains('dark-mode');
                        ctx.fillStyle = isDark 
                            ? `rgba(255, 255, 255, ${alpha})` 
                            : `rgba(0, 0, 0, ${alpha})`;
                        
                        ctx.fillText(selectedChar, snappedX, snappedY);
                    }
                });
            });

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
